{"meta":{"title":"看看你踩进了什么","subtitle":"DC的小水洼","description":"个人博客，DC的小水洼","author":"DC","url":"http://ldc5886.github.io","root":"/"},"pages":[{"title":"about","date":"2019-05-28T05:45:30.000Z","updated":"2019-05-28T08:24:39.392Z","comments":true,"path":"about/index.html","permalink":"http://ldc5886.github.io/about/index.html","excerpt":"","text":"关于这个站点个人小资料架和学习过程的收藏 想给自己一份不为什么的坚持吧~ 关于我前端小白热爱开源项目、热爱新技术、热爱新事物。 关于工作找工作持续杯具ing。。。 关于学习终身学习目标者 关于座右铭 痛苦才能成长改变才是不变 关于爱好动漫党 偶尔也刷刷日剧 如果要勾搭我 Email: ldcwy163@163.com GitHub: https://github.com/LDC5886"}],"posts":[{"title":"快速搭建服务---live-server","slug":"live-server","date":"2019-10-25T16:00:00.000Z","updated":"2019-11-10T11:15:42.603Z","comments":true,"path":"2019/10/26/live-server/","link":"","permalink":"http://ldc5886.github.io/2019/10/26/live-server/","excerpt":"","text":"live-server是什么？这是一个具有实时重载功能的小型开发服务器。用它来热加载你的HTML / JavaScript / CSS文件，但不能用于部署最终的网站。live-server官网 优点一键安装，实现自动刷新，架设本地服务器环境。比起 gulp 构建 实现自动刷新，架设本地服务器环境，需要安装自动刷新插件gulp-livereload，架设本地服务器插件gulp-server。live-server简直一步到位。只要安装live-server，就可以解决自动刷新和架设本地服务器环境的问题。 使用场景在你写好页面之后，查看打包好的文件可以实现的功能包括：搭建临时的服务修改文件浏览器自动刷新自动打开项目 安装使用1、安装nodeJs2、打开命令行工具，输入命令npm install -g live-server3、然后在项目根目录执行live-server --port=8080，就可以看到了注意事项输入命令 live-sever 启动，默认会自动打开浏览器，并且访问8080端口。如果8080端口被占用，可以使用命令行参数更换端口。根目录文件名不允许以”.”开头，否则无法热更新 其他方式： 12345git clone https://github.com/tapio/live-servercd live-servernpm install # Local dependencies if you want to hacknpm install -g # Install globally 命令行参数123456789101112131415161718192021* `--port=NUMBER` - 选择要使用的端口，默认值：PORT env var或8080 * `--host=ADDRESS` - 选择要绑定的主机地址，默认值：IP env var或0.0.0.0（“任意地址”）* `--no-browser` - 禁止自动Web浏览器启动 * `--browser=BROWSER` - 指定浏览器使用，而不是系统默认 * `--quiet | -q` - 禁止记录 * `--verbose | -V` - 更多日志记录（记录所有请求，显示所有侦听的IPv4接口等） * `--open=PATH` - 启动浏览器到PATH而不是服务器根目录 * `--watch=PATH` - 用逗号分隔的路径来专门监视更改（默认值：观看所有内容）* `--ignore=PATH` - 要忽略的逗号分隔的路径字符串（[anymatch](https://github.com/es128/anymatch) -compatible definition） * `--ignorePattern=RGXP`-文件的正则表达式忽略（即`.*\\.jade`）（**不推荐使用**赞成`--ignore`） * `--middleware=PATH` - 导出.js文件的路径导出中间件功能添加; 可以是一个没有路径的名字，也不是引用`middleware`文件夹中捆绑的中间件的扩展名 * `--entry-file=PATH` - 提供这个文件（服务器的根相对），以取代丢失的文件（对单页面应用程序有用） * `--mount=ROUTE:PATH` - 在定义的路线下提供路径内容（可能有多个定义） * `--spa` - 将请求从/ abc转换为/＃/ abc（适用于单页面应用程序） * `--wait=MILLISECONDS` - （默认100ms）等待所有更改，然后重新加载 * `--htpasswd=PATH` - 启用期待位于PATH的htpasswd文件的http-auth * `--cors` - 为任何来源启用CORS（反映请求源，支持凭证的请求） * `--https=PATH` - 到HTTPS配置模块的路径 * `--proxy=ROUTE:URL` - 代理ROUTE到URL的所有请求 * `--help | -h` - 显示简短的使用提示和退出 运行原理live-server是一个简单的节点应用程序，用于工作目录及其子目录。它也监视文件的变化，当这种情况发生时，它通过web套接字连接向浏览器发送消息，指示它重新加载。为了让客户端支持这个，服务器为每个请求的html文件注入一小段JavaScript代码。这个脚本建立了web套接字连接并监听重载请求。通过从DOM中查找引用的样式表，并触发浏览器再次获取并解析它们，可以刷新CSS文件，而无需整页重新加载。所以，让你打开chome控制台，发现多了一小段JavaScript代码请不要惊慌。","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"node","slug":"node","permalink":"http://ldc5886.github.io/tags/node/"}],"author":"D橙"},{"title":"WebStorm的安装及破解","slug":"WebStorm的安装及破解","date":"2019-10-25T16:00:00.000Z","updated":"2019-11-10T09:56:17.648Z","comments":true,"path":"2019/10/26/WebStorm的安装及破解/","link":"","permalink":"http://ldc5886.github.io/2019/10/26/WebStorm%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%A0%B4%E8%A7%A3/","excerpt":"","text":"一. WebStorm的安装(以2018.2版本为例) 运行“WebStorm-2018.2.exe”开始安装，默认安装目录【C:\\Program Files\\JetBrains\\WebStorm 2018.2】 勾选创建webstorm 2018.2桌面快捷方式，包括32位和64位，以及自行选择关联文件格式，建议全选； 等待软件安装完成，但不要运行软件，以免影响后面的破解操作； 二. WebStorm的破解方法一：License serverLicense server可以说是webstorm最简单方便的激活方式了，只要输入有效的地址点击一下激活按钮即可免费使用webstorm。但是每次webstom更新几乎都会导致之前的地址失效，在网上寻找也比较麻烦。 方法二：：使用破解补丁进行激活（注意：webstorm版本号要与补丁包的版本相同才能用。）首先复制 JetbrainsCrack.jar文件到安装目录/ bin 中 打开bin文件夹里头的这两个文件，推荐是两个文件都要修改，记事本格式打开就行 在后面加上-javaagent:你的bin文件夹地址/补丁包的名字.jar注意： “-javaagent:d:\\webstrom...” - 不要有空格！路径根据自己的安装目录添加！ 两个文件加好代码以后，保存关闭，重启webstorm，将第三步的那句代码加到激活框的activation code中，都是复制粘贴，如果补丁包不可用的话，左下角那一块会提示key is invalue,且ok键不能点击，这时需要另外更换有效的补丁包才行。 方法三：使用注册码打开网站IntelliJ IDEA 注册码，点击获取注册码 将注册码直接粘贴在webstorm激活框的activation code栏上，先不要点ok，等修改完host之后再点OKwindows的hosts路径是C:\\Windows\\System32\\drivers\\etc\\hostsmac 的hosts路径是：/etc/hosts使用记事本打开hosts文件，在文件末尾添加如下信息,然后保存返回点击ok即可 120.0.0.0 account.jetbrains.com0.0.0.0 www.jetbrains.com 三. WebStorm的汉化包安装将resources_cn.jar文件复制到安装目录下的 lib文件夹 中，重启webstrom即可。","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"webstrom","slug":"webstrom","permalink":"http://ldc5886.github.io/tags/webstrom/"}],"author":"D橙"},{"title":"静态html文件，使用公共头部和尾部的解决办法","slug":"页面公共部分部分部署方法","date":"2019-09-30T16:00:00.000Z","updated":"2019-10-13T14:04:41.158Z","comments":true,"path":"2019/10/01/页面公共部分部分部署方法/","link":"","permalink":"http://ldc5886.github.io/2019/10/01/%E9%A1%B5%E9%9D%A2%E5%85%AC%E5%85%B1%E9%83%A8%E5%88%86%E9%83%A8%E5%88%86%E9%83%A8%E7%BD%B2%E6%96%B9%E6%B3%95/","excerpt":"","text":"本地合并将HTML硬拆成头、尾、内容三个部分的文件，在预览或者发布之前用脚本手工合并。 自己写代理（比如用node），请求文件的时候自动加上头尾文件。 iframe这个方法比较古老，以前很常用，但因为总是容易有一些导航链接等等的问题，而且页面结构的杂乱、不易被搜索引擎搜索，因此，目前大家普遍使用其他的方法替代进行替代了。 利用js或ajax从服务器上进行请求，取回需要的公共页面然后插入页面注意 因为有请求，所以需要有服务器环境才能正常使用，若是使用本地文件打开，则会出现跨域问题？谷歌浏览器会有报错信息：Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.若只想在开发时调试使用可参考Chrome浏览器开启Ajax跨域访问调试进行解决 以jQuery为例： 123456&lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt;/*导入尾部*/$(document).ready(function()&#123; $(\".headerpage\").load(\"header.html\"); $(\".footer\").load(\"page/footer.html\");&#125;); 请求的html文件里不需要是完整的HTML，这包含标签内容即可例如： 123456789&lt;!--footer.html页面--&gt;&lt;footer&gt; &lt;ul class=\"g-flex\"&gt; &lt;li class=\"g-flex-auto\"&gt;&lt;a href=\"#\" class=\"i-b\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"g-flex-auto\"&gt;&lt;a href=\"#\" class=\"i-b\"&gt;分类&lt;/a&gt;&lt;/li&gt; &lt;li class=\"g-flex-auto\"&gt;&lt;a href=\"#\" class=\"i-b\"&gt;订单&lt;/a&gt;&lt;/li&gt; &lt;li class=\"g-flex-auto\"&gt;&lt;a href=\"#\" class=\"i-b\"&gt;我的&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/footer&gt; 使用ajax动态拉取填充。h5新增的embed标签：1&lt;embed type=&quot;text/html&quot; src=&quot;header.html&quot; /&gt; 用 JavaScript 填充內容所有的页面都有： 123&lt;div id=\"header\"&gt;&lt;/div&gt;&lt;div id=\"footer\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"loader.js\"&gt; ：123document.getElementById(&quot;header&quot;).innerHTML = &quot;....&quot;;document.getElementById(&quot;footer&quot;).innerHTML = &quot;....&quot;; 用php写前端页面:123&lt;?php include &quot;./public/sidebar.html&quot; ?&gt; 服务端shtml包含;web服务器（比如IIS）中设定包含;后台模板引擎处理（字符串拼接）。总结一些页面公共头部统一部署方法–前端html 引入公共的头部和底部Html页面对于导航及底部栏等公共部分的引用网页公共部分引入的几种方法简述iframe异步加载性能优化及无阻塞加载","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"html","slug":"html","permalink":"http://ldc5886.github.io/tags/html/"}],"author":"D橙"},{"title":"nodejs安装以及环境配置","slug":"nodejs安装以及环境配置","date":"2019-09-27T16:00:00.000Z","updated":"2019-10-13T14:05:37.835Z","comments":true,"path":"2019/09/28/nodejs安装以及环境配置/","link":"","permalink":"http://ldc5886.github.io/2019/09/28/nodejs%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"一、安装环境1、本机系统：Windows 7（32位）2、Node.js：v6.9.2LTS（32位） 二、安装Node.js步骤1、官网下载对应你电脑系统的Node.js版本:2、选安装目录进行安装3、环境配置4、测试 三、前期准备1、Node.js简介简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。2、下载Node.js打开官网下载链接:https://nodejs.org/en/download/我这里下载的是node-v6.9.2-x64.msi` 四、开始安装1、下载完成后，双击“node-v6.9.2-x64.msi”，开始安装Node.js 点击【Next】按钮 勾选复选框，点击【Next】按钮 Node.js默认安装路径为“C:\\Program Files\\nodejs\\”，你可以修改，我在此处改为D:\\Develop\\nodejs下，修改好目录后，点击【Next】按钮 安装完后点击【Finish】按钮完成安装 至此Node.js已经安装完成，可以先进行下简单的测试安装是否成功了，后面还要进行环境配置在键盘按下【win+R】键，输入cmd，然后回车，打开cmd窗口 安装完后的目录如下图所示： 此处说明下：新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西 五、环境配置说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到C:\\Users\\用户名\\AppData\\Roaming\\npm路径中，占C盘空间。例如：我希望将全模块所在路径和缓存路径放在我node.js安装的文件夹中，则在我安装的文件夹D:\\Develop\\nodejs下创建两个文件夹【node_global】及【node_cache】如下图： 创建完两个空文件夹之后，打开cmd命令窗口，输入 123npm config set prefix &quot;D:\\Develop\\nodejs\\node_global&quot;npm config set cache &quot;D:\\Develop\\nodejs\\node_cache&quot; 接下来设置环境变量，关闭cmd窗口，“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量” 进入环境变量对话框，在【系统变量】下新建【NODE_PATH】，输入D:\\Develop\\nodejs\\node_global\\node_modules，在【用户变量】下，编辑【Path】，将原本相应npm的路径C:\\Users\\用户名\\AppData\\Roaming\\npm改为：D:\\Program Files\\nodejs\\node_global,最后确定即可 六、测试配置完后，安装个module测试下，我们就安装最常用的express模块，打开cmd窗口，输入如下命令进行模块的全局安装：(执行该命令前，文件夹【node_global】下应该是空的，若配置正确，执行后该文件夹下会出现文件对应的配置文件) 1npm install express -g # -g是全局安装的意思 七、其他命令设置淘宝镜像： 12 npm config set registry &quot; https://registry.npm.taobao.org &quot;npm install -g cnpm --registry=https://registry.npm.taobao.org","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"js","slug":"js","permalink":"http://ldc5886.github.io/tags/js/"},{"name":"node","slug":"node","permalink":"http://ldc5886.github.io/tags/node/"}],"author":"D橙"},{"title":"13版baidu地图APi的使用","slug":"13版baidu地图APi的使用","date":"2019-08-26T16:00:00.000Z","updated":"2019-10-13T14:07:28.402Z","comments":true,"path":"2019/08/27/13版baidu地图APi的使用/","link":"","permalink":"http://ldc5886.github.io/2019/08/27/13%E7%89%88baidu%E5%9C%B0%E5%9B%BEAPi%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"baidu地图APi使用时的调用代码记录","text":"baidu地图APi使用时的调用代码记录 设置样式，并调用相应的js文件12345&lt;style type=&quot;text/css&quot;&gt; html,body&#123;margin:0;padding:0;&#125; .iw_poi_title &#123;color:#CC5522;font-size:14px;font-weight:bold;overflow:hidden;padding-right:13px;white-space:nowrap&#125; .iw_poi_content &#123;font:12px arial,sans-serif;overflow:visible;padding-top:4px;white-space:-moz-pre-wrap;word-wrap:break-word&#125;&lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?key=&amp;v=1.1&amp;services=true&quot;&gt;&lt;/script&gt; 创建容器12&lt;!--百度地图容器--&gt;&lt;div style=\"width:540px;height:278px;border:#ccc solid 1px;\" id=\"dituContent\"&gt;&lt;/div&gt; 加入初始化函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;script type=\"text/javascript\"&gt; //创建和初始化地图函数： function initMap()&#123; createMap();//创建地图 setMapEvent();//设置地图事件 addMapControl();//向地图添加控件 addMarker();//向地图中添加marker &#125; //创建地图函数： function createMap()&#123; var map = new BMap.Map(\"dituContent\");//在百度地图容器中创建一个地图 var point = new BMap.Point(113.290283,23.102333);//定义一个中心点坐标 （按需更改） map.centerAndZoom(point,18);//设定地图的中心点和坐标并将地图显示在地图容器中 window.map = map;//将map变量存储在全局 &#125; //地图事件设置函数： function setMapEvent()&#123; map.enableDragging();//启用地图拖拽事件，默认启用(可不写) map.enableScrollWheelZoom();//启用地图滚轮放大缩小 map.enableDoubleClickZoom();//启用鼠标双击放大，默认启用(可不写) map.enableKeyboard();//启用键盘上下左右键移动地图 &#125; //地图控件添加函数： function addMapControl()&#123; //向地图中添加缩放控件 var ctrl_nav = new BMap.NavigationControl(&#123;anchor:BMAP_ANCHOR_TOP_LEFT,type:BMAP_NAVIGATION_CONTROL_LARGE&#125;); map.addControl(ctrl_nav); //向地图中添加缩略图控件 var ctrl_ove = new BMap.OverviewMapControl(&#123;anchor:BMAP_ANCHOR_BOTTOM_RIGHT,isOpen:1&#125;); map.addControl(ctrl_ove); //向地图中添加比例尺控件 var ctrl_sca = new BMap.ScaleControl(&#123;anchor:BMAP_ANCHOR_BOTTOM_LEFT&#125;); map.addControl(ctrl_sca); &#125; //标注点数组 （同上，名称，地址，坐标点按需更改） var markerArr = [&#123;title:\"广州新时代教育有限公司\",content:\"广州市海珠区新港西路1号（银华大厦1401）\",point:\"113.290283|23.102333\",isOpen:1,icon:&#123;w:21,h:21,l:0,t:0,x:6,lb:5&#125;&#125; ]; //创建marker function addMarker()&#123; for(var i=0;i&lt;markerArr.length;i++)&#123; var json = markerArr[i]; var p0 = json.point.split(\"|\")[0]; var p1 = json.point.split(\"|\")[1]; var point = new BMap.Point(p0,p1); var iconImg = createIcon(json.icon); var marker = new BMap.Marker(point,&#123;icon:iconImg&#125;); var iw = createInfoWindow(i); var label = new BMap.Label(json.title,&#123;\"offset\":new BMap.Size(json.icon.lb-json.icon.x+10,-20)&#125;); marker.setLabel(label); map.addOverlay(marker); label.setStyle(&#123; borderColor:\"#808080\", color:\"#333\", cursor:\"pointer\" &#125;); (function()&#123; var index = i; var _iw = createInfoWindow(i); var _marker = marker; _marker.addEventListener(\"click\",function()&#123; this.openInfoWindow(_iw); &#125;); _iw.addEventListener(\"open\",function()&#123; _marker.getLabel().hide(); &#125;) _iw.addEventListener(\"close\",function()&#123; _marker.getLabel().show(); &#125;) label.addEventListener(\"click\",function()&#123; _marker.openInfoWindow(_iw); &#125;) if(!!json.isOpen)&#123; label.hide(); _marker.openInfoWindow(_iw); &#125; &#125;)() &#125; &#125; //创建InfoWindow function createInfoWindow(i)&#123; var json = markerArr[i]; var iw = new BMap.InfoWindow(\"&lt;b class='iw_poi_title' title='\" + json.title + \"'&gt;\" + json.title + \"&lt;/b&gt;&lt;div class='iw_poi_content'&gt;\"+json.content+\"&lt;/div&gt;\"); return iw; &#125; //创建一个Icon function createIcon(json)&#123; var icon = new BMap.Icon(\"http://app.baidu.com/map/images/us_mk_icon.png\", new BMap.Size(json.w,json.h),&#123;imageOffset: new BMap.Size(-json.l,-json.t),infoWindowOffset:new BMap.Size(json.lb+5,1),offset:new BMap.Size(json.x,json.h)&#125;) return icon; &#125; initMap();//创建和初始化地图&lt;/script&gt; 更改坐标中心点进入创建地图-百度地图生成器，查找出对应地点的中心点经纬度后复制替换进上方初始化部分两处按需更改的地方即可","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[],"author":"D橙"},{"title":"swiper 报错","slug":"ER-swiper3.4在Firefox无法自适应","date":"2019-08-26T16:00:00.000Z","updated":"2019-10-13T14:10:19.066Z","comments":true,"path":"2019/08/27/ER-swiper3.4在Firefox无法自适应/","link":"","permalink":"http://ldc5886.github.io/2019/08/27/ER-swiper3.4%E5%9C%A8Firefox%E6%97%A0%E6%B3%95%E8%87%AA%E9%80%82%E5%BA%94/","excerpt":"碰到一个问题，在使用swiper3.4版本的时候，发现在Chrome浏览器中显示正常，可以进行自适应，但在Firefox就不行，暂时性解决","text":"碰到一个问题，在使用swiper3.4版本的时候，发现在Chrome浏览器中显示正常，可以进行自适应，但在Firefox就不行，暂时性解决 如下图：Chrome中的显示（我的屏幕宽度1400px）![Swiper 3.4.2-not-adaptive-in-Firefox](/images/Swiper 3.4.2-not-adaptive-in-Firefox01.png)Firefox中的显示![Swiper 3.4.2-not-adaptive-in-Firefox](/images/Swiper 3.4.2-not-adaptive-in-Firefox02.png) 解决办法![Swiper 3.4.2-not-adaptive-in-Firefox](/images/Swiper 3.4.2-not-adaptive-in-Firefox03.png)如图，将.swiper-container部分的overflow：hidden去掉就可以了（暂时还不知道是为什么，有时间详细摸索一下）","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"error","slug":"error","permalink":"http://ldc5886.github.io/tags/error/"},{"name":"swiper","slug":"swiper","permalink":"http://ldc5886.github.io/tags/swiper/"}],"author":"D橙"},{"title":"a标签href的使用","slug":"a标签href的使用","date":"2019-08-18T16:00:00.000Z","updated":"2019-10-13T14:16:51.610Z","comments":true,"path":"2019/08/19/a标签href的使用/","link":"","permalink":"http://ldc5886.github.io/2019/08/19/a%E6%A0%87%E7%AD%BEhref%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"今天碰到了要求手机点击页面电话号码，会自动弹出拨打电话的功能，原以为很复杂，结果没想到意外的简单，还了解到了同类的一些应用方法","text":"今天碰到了要求手机点击页面电话号码，会自动弹出拨打电话的功能，原以为很复杂，结果没想到意外的简单，还了解到了同类的一些应用方法 点击号码呼出及保存调出拨号界面（电脑端无法显示效果，手机端才能看到） 方式一 使用wtai协议进行拨打电话（不常用）塞班与安卓上支持，iphone不支持 1&lt;a href=”wtai://wp/mc;135xxxxxxxx ”&gt;点击拨打135xxxxxxxx &lt;/a&gt; iphone支持 1&lt;a href=”callto：135xxxxxxxx ”&gt;点击拨打135xxxxxxxx &lt;/a&gt; 这种方式拨打电话只在塞班与安卓上支持，而iphone是不支持的。 方式二（常用） 1&lt;a href=”tel:135xxxxxxxx ”&gt;点击拨打135xxxxxxxx &lt;/a&gt; 这种方式塞班、安卓与iphone都支持 注：在电话号码前面可以加上 + （加号）表示国际号码。 在android的浏览器中，如果电话号码是 XXX-XXX-XXXX的型式的话，用户点击的时候，拨号面板不用上述方式也会激活，但是如果不是这一特定的格式，那么拨号功能就需要这般手动激活。 调出保存电话号码界面1&lt;a href=”wtai://wp/ap;135xxxxxxxx”&gt;点击存储135xxxxxxxx&lt;/a&gt; 点击网页上显示的邮箱号码发送邮件12345&lt;a href=”mailto:xx@zhudongdong.cn”&gt;邮箱&lt;/a&gt;或&lt;form action=\"mailto:sample@163.com\"&gt;&lt;/form&gt;mailto后跟的是收信人。 可使用参数 to 收信人 suject 主题 cc 抄送 bcc 暗抄送 body 内容 参数传递方式同页面之间传递值一样，可以使用查询字符串，也可以用formquerystring方式： 1&lt;a href=\"mailto:sample@163.com?subject=test&amp;cc=sample@hotmail.com&amp;body=use mailto sample\"&gt;send mail&lt;/a&gt; form方式 12345&lt;form name='sendmail' action='mailto:sample@163.com'&gt;&lt;input name='cc' type='text' value='sample@hotmail.com'&gt;&lt;input name='subject' type='text' value='test'&gt;&lt;input name='body' type='text' value='use mailto sample'&gt;&lt;/form&gt; 两种方式同样传递所有参数。 用鼠标单击一下该超级连接的话，浏览器会自动调用系统默认的邮件客户端程序，同时按照设定好的变量值，如subject、cc等，在邮件客户端中自动填入设定好的值。 发送至多个地址如果你要将邮件发送到多个邮箱，可以使用分号”;”隔开，如下所示： 1&lt;a href=\"mailto:sample@163.com;abc@qq.com?subject=test&amp;cc=sample@hotmail.com&amp;body=use mailto sample\"&gt;send mail&lt;/a&gt; 发送内容换行如果想使邮件内容（变量body对应的变量值）换行，则直接加上标签，如下所示： 1234567&lt;a href=\"mailto:sample@163.com?subject=test&amp;cc=sample@hotmail.com&amp;body=use&lt;br&gt;mailto sample\"&gt;send mail&lt;/a&gt;``` ### 点击发送短信```html&lt;a href=\"sms:10086?body=message_body\"&gt;给 10086 发送内容为\"message_body\"的短信&lt;/a&gt;&lt;a href=\"sms:12345678,98765432?body=hello\"&gt;给12345678和98765432发送内容为\"hello\"的短信&lt;/a&gt; 传参方式参考邮件 点击发送地图定位GPS1234&lt;a href=\"geopoint:[经度],[纬度]\"&gt;我的位置&lt;/a&gt;例如：&lt;a href=\"geopoint:116.281469,39.866035\"&gt;我的位置&lt;/a&gt; 下载图片等文件1&lt;a href=\"img/WC.png\" download=\"WC.png\"&gt;下载图片&lt;/a&gt; href中只需要放上图片的链接，只需要这样你就可以点击下载图片这个文字时能直接下载对应的图片。如果是其他格式的文件，你只需要更改download=&quot;filename&quot;里面的filename即可,如： 1&lt;a href=\"public/jym_apk_1.0.zip\" download=\"jym_apk_1.0.zip\"&gt;下载apk&lt;/a&gt; 激活应用市场或在某个网站搜索内容12345678&lt;a href=\"market://search?q=MyApp\"&gt;Android Market link&lt;/a&gt; //激活Android市场并在其中搜索MyApp&lt;a href=\"http://store.ovi.com/content/iPhone\"&gt;Nokia Market link&lt;/a&gt; //激活诺基亚Nokia应用市场并在其中搜索iPhone&lt;a href=\"http://marketplace.windowsphone.com/details.aspx?appId=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"&gt;windowsphone&lt;/a&gt; //微软的应用市场,其中 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx 指的是应用的ID&lt;a href=\"http://appworld.blackberry.com/webstore/content/XXXXX\"&gt;blackberry&lt;/a&gt; //黑莓的应用市场&lt;a href=\"http://appworld.blackberry.com/webstore/vendor/XXXX\"&gt;MyApp&lt;/a&gt; //黑莓的应用市场作者页面的URL,XXXX是指作者的ID 激活聊天工具并作出动作 Yahoo Messager[动作]有：addfriend, sendIM, call123&lt;a href=\"ymsgr:[动作]?[用户名]&amp;m=[消息]\"&gt;Yahoo Messager&lt;/a&gt;&lt;a href=\"ymsgr:sendIM?my.account@yahoo.com\"&gt;给my.account@yahoo.com发消息&lt;/a&gt; Windows Messager (MSN)[动作]有：chat （聊天）, add （添加成联系人）, voice （语音）, video （视频）123 &lt;a href=\"msnim:[动作]?contact=[用户名]\"&gt;Windows Messager&lt;/a&gt;&lt;a href=\"msnim:chat?contact=my.account@hotmail.com\"&gt;MSN&lt;/a&gt; QQ客服在线聊天1&lt;a href=\"mqqwpa://im/chat?chat_type=wpa&amp;uin=229890321&amp;version=1&amp;src_type=web&amp;web_src=http://m.haishiit.com/\"&gt;QQ客服：229890321&lt;/a&gt; 参考来源：a标签属性href中的tel及mailto用处在mobile手机上通过网页拨打电话及存储号码点击网页上的手机号码直接拨打电话(针对手机端)发送邮件移动端a标签的妙用（拨号、短信、邮件等）移动端网页站点调用拨打电话发送短信等功能","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"html","slug":"html","permalink":"http://ldc5886.github.io/tags/html/"}],"author":"D橙"},{"title":"开发者工具查看dom元素上绑定的js事件的方法","slug":"开发者工具查看dom元素上绑定的js事件的方法","date":"2019-08-13T16:00:00.000Z","updated":"2019-10-13T14:06:29.826Z","comments":true,"path":"2019/08/14/开发者工具查看dom元素上绑定的js事件的方法/","link":"","permalink":"http://ldc5886.github.io/2019/08/14/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8Bdom%E5%85%83%E7%B4%A0%E4%B8%8A%E7%BB%91%E5%AE%9A%E7%9A%84js%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"查看原生绑定的事件函数代码所谓原生就是通过addEventListener方法绑定到dom元素上。这个好办： 审查绑定事件的元素（对着它右键-&gt;审查元素） 在弹出的Elements视图的控制台，右侧点击“Event Listeners”页签 然后就能看到所有绑定在该元素的事件了 点开后，找到handler，右击鼠标，选择“Show Function Definition”菜单。就能跳到绑定到该元素的事件函数的源码位置了。 为省去查看属性的麻烦，jquery1.x可以直接在控制台执行$.cache[$(&#39;#clickMe&#39;).get(0)[$.expando]]输出元素上绑定的东西，而不是先去查看元素上jQueryxxxxxxx的属性的值了 查看jquery1.x版本绑定的事件函数代码所有jquery绑定的事件函数，你通过上面的方式，跳到的都是jquery的代码，而且永远是那一个地方。针对jquery的查看方式 还是审查元素 点击“Properties”视图。选择第一个，展开 找到一个‘jQueryxxxxx(一串数字)’这样的属性，记住它的值（一般是一个数字）N，如jQuery12354154868454445:17的N就是17 然后左侧切到Console视图，在控制台里执行$.cache[N] 然后就会出来绑定在这个元素上的东西了。展开events，里面就有你想要查看的真实函数了。 右击具体事件下的handle后面的function…，然后选择“Show Function Definition”就可以看到了源码。 查看jquery1.8.0版本之前dom绑定的事件函数代码在1.8.0版本之前，若要获取某个DOM绑定的事件函数可以这样写： 1$.data(domObj,'events');//或者$('selector').data('events') domObj节点必须为dom节点对象,event为事件 jquery1.8.0版本后1$._data(domObj,'events');//注意，这里不能像$('selector')._data('events')这样用了。 兼容使用jquery1.8.0和其后版本1var eventsData = $.data(domObj,'events') || $._data(domObj,'events'); 参考来源：宝哥教你查看jquery绑定的事件函数JQuery获取 绑定过的事件函数","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[],"author":"D橙"},{"title":"移动端布局方式","slug":"移动端布局方式","date":"2019-08-05T16:00:00.000Z","updated":"2019-10-13T14:14:08.634Z","comments":true,"path":"2019/08/06/移动端布局方式/","link":"","permalink":"http://ldc5886.github.io/2019/08/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/","excerpt":"","text":"一、移动端app分类1、Native App原生app手机应用程序 使用原生的语言开发的手机应用，Android系统用的是java，ios系统用的是object-C 2、Hybrid App 混合型app手机应用程序 混合使用原生的程序和html5页面开发的手机应用 3、Web App 基于Web的app手机应用程序 完全使用html5页面加前端js框架开发的手机应用 二、Viewport视口 视口是移动设备上用来显示网页的区域，一般会比移动设备可视区域大，宽度可能是980px或者1024px，目的是为了显示下整个为PC端设计的网页，这样带来的后果是移动端会出现横向滚动条，为了避免这种情况，移动端会将视口缩放到移动端窗口的大小。这样会让网页不容易观看，可以用meta标签，name=”viewport”来设置视口的大小，将视口的大小设置为和移动设备可视区一样的大小。 设置方法如下：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scale=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0&quot;&gt; 三、页面适配方法设备有多种不同的分辨率，除了移动端与pc端全适配常常采用的流体布局+响应式布局的方案外，单独针对移动端则有如下几种： 流体布局+少量响应式 流体布局就是使用百分比来设置元素的宽度，元素的高度按实际高度写固定值，流体布局中，元素的边线（border）无法用百分比，可以使用样式中的计算函数calc()来设置宽度，或者使用box-sizing属性将盒子设置为border-box。 响应式布局就是使用媒体查询的方式，通过查询浏览器的宽度，不同的宽度应用不同的样式块，每个样式块对应的是该宽度下的布局方式，从而实现响应式布局，响应式布局的页面可以适配多种终端屏幕（pc、平板、手机）。 基于rem的布局em单位是参照元素自身的文字大小来设置尺寸 rem指的是参照根节点的文字大小。根节点指的是html标签，设置html标签的大小，其他的元素相关尺寸设置用rem，这样，所有元素都有了统一的参照标准，改变html文字的大小，就会改变所有元素用rem设置的尺寸大小。 弹性盒模型容器属性display:flex声明使用弹性盒布局(全部都是在父元素上设置),相对于把子元素变为行内块元素，并且之间不会产生间隙。 参考来源：深入理解 CSS3 弹性盒布局模型移动端页面布局","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"mobile","slug":"mobile","permalink":"http://ldc5886.github.io/tags/mobile/"}],"author":"D橙"},{"title":"微信小程序反编译方法（19.7.24亲测可用）","slug":"微信小程序反编译方法（19.7.24亲测可用）","date":"2019-07-23T16:00:00.000Z","updated":"2019-10-13T14:21:56.483Z","comments":true,"path":"2019/07/24/微信小程序反编译方法（19.7.24亲测可用）/","link":"","permalink":"http://ldc5886.github.io/2019/07/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95%EF%BC%8819.7.24%E4%BA%B2%E6%B5%8B%E5%8F%AF%E7%94%A8%EF%BC%89/","excerpt":"今天让我仿写一个微信小程序，实在是无从下手，只好想办法搞搞源码来学习一下 这种方法，并不能反编译出所有的小程序源码","text":"今天让我仿写一个微信小程序，实在是无从下手，只好想办法搞搞源码来学习一下 这种方法，并不能反编译出所有的小程序源码 获取到.wxapkg文件方式一 模拟器法准备材料： node.js运行环境（自行百度安装教程）下载安装好nodejs 反编译的脚本（需要做一定的修改，否则编译出来的文件缺少样式，修改方法见下方脚本的修改）使用Github上qwerty472123大神写的node.js版本的，当然也有其它版本的，例如python版等，自行度娘。下载地址：旧版Wechat App(微信小程序,.wxapkg)解包及相关文件(.wxss,.json,.wxs,.wxml)还原工具2019版2019小程序解包 解决$gwx报错问题 安卓模拟器（要求自带root权限）例如夜神模拟器，腾讯手游助手等 具体步骤如下： 打开安装好的安卓模拟器，并在模拟器中安装QQ、微信、RE管理器RE管理器的下载地址https://pan.baidu.com/s/1PPBx08rNutXxhlMMJbuTpQ 设置一下模拟器以夜神模拟器举例首先到模拟器内部设置超级用户权限这些操作的目的都是为了能让RE管理器顺利的获取到ROOT权限接下来在模拟器里打开微信，然后在微信中运行你想要获取的下程序（这其实是让微信把小程序的源文件包从服务器下载到了本地了） 在模拟器微信中运行一下后，直接切回模拟器桌面运行RE管理器 来到根目录下的/data/data/com.tencent.mm/MicroMsg//appbrand/pkg/就抵达了目的文件夹你会看到发现里面的一些.wxapkg后缀的文件，就是它们没错啦，可以根据使用的时间来判断那个是你刚才从服务器下载过来的 这里重要声明一下：虽然微信小程序的包后缀是.wxapkg，但有一些包的依赖后缀也是.wxapkg，真正的小程序包大小1M左右，而依赖包大小2、3M甚至更多。所以一股脑的反编译.wxapkg 类型的文件可能会报错：Error: This Package is unrecognizable, please decrypted every type of file by hand.，遇见这个问题请自知，你可能没找对包！ 一般小程序的文件不会太大，可以结合时间来判断，长按压缩所选文件,然后再将压缩好的包通过QQ发送到我的电脑 如果不进行压缩的话，是无法将这个文件通过QQ来发送的 最后将发送过来的文件进行解压。这样几步简单操作，就成功拿到了小程序的源文件了。 方式二 手机备份法（我用的这种）准备材料：1.、2.同方式一 一台带有备份功能的智能手机 具体步骤如下： 备份微信应用：为便于查找，最好单独备份微信，以安卓手机为例，大致流程如下：设置——存储与备份——备份手机数据——添加备份——应用——选择微信，然后点击确定，等待备份完成即可。PS：如果是获取别人的小程序，不清楚小程序结构，那么最好是把微信中其他的小程序都删掉，只保留要查找的小程序进行访问后对微信单独备份，这样备份之后的文件中的编译包就只有需要的这个小程序了。 查找备份文件：文件管理——全部文件——backup——App中找到com.tencent.mm.zip,这就是微信备份文件了（注意不同手机目录结构会不同）。也可以直接搜索com.tencent.mm.zip最后通过qq或微信将这个压缩包分享到电脑上。 查找小程序编译包文件： 解压文件，点击进入MicroMsg文件夹,找到文件名为串码格式的文件夹，如下，需要点进去确认下：点击进去——第一个appbrand——pkg，下方的那些.wxapkg后缀的文件就是 使用反编译脚本解包.wxapkg将反编译脚本从github下载 或者 clone 到本地某个目录打开nodejs命令窗口用cd命令进入到你clone或者下载好的反编译脚本目录下在node命令窗口中依次使用如下命令安装依赖包： 1234567npm install esprimanpm install css-treenpm install cssbeautifynpm install vm2npm install uglify-esnpm install js-beautifynpm install escodegen 在当前目录下输入node wuWxapkg.js 想要反编译的文件路径（注意空格！！！）然后回车即可，如下图 最后稍等一会在安装包目录下会出现一个与编译文件同名的文件夹，那个就是编译好的源码文件夹了 打开源码文件打开微信开发者工具——左上角“项目”——“导入项目”，然后如图所示 脚本的修改由于新版小程序做了改动，直接使用下载的脚本编译出来的文件会缺少wxss的样式文件，并且编译过程会报错，需要做如下修改后再编译才行 将反编译脚本wuWxss.js文件中的 123456789function runVM(name,code)&#123; let wxAppCode=&#123;&#125;,handle=&#123;cssFile:name&#125;; let vm=new VM(&#123;sandbox:Object.assign(new GwxCfg(),&#123;__wxAppCode__:wxAppCode,setCssToHead:cssRebuild.bind(handle)&#125;)&#125;); vm.run(code); for(let name in wxAppCode)if(name.endsWith(\".wxss\"))&#123; handle.cssFile=path.resolve(frameName,\"..\",name); wxAppCode[name](); &#125;&#125; 修改为 123456789101112131415161718192021function runVM(name,code)&#123;let wxAppCode = &#123;&#125;; let handle = &#123;cssFile: name&#125;; let gg = new GwxCfg(); let tsandbox = &#123; $gwx: GwxCfg.prototype[\"$gwx\"], __mainPageFrameReady__: GwxCfg.prototype[\"$gwx\"], //解决 $gwx is not defined __vd_version_info__: GwxCfg.prototype[\"$gwx\"], //解决 __vd_version_info__ is not defined __wxAppCode__: wxAppCode, setCssToHead: cssRebuild.bind(handle) &#125; let vm = new VM(&#123;sandbox: tsandbox&#125;); vm.run(code); for (let name in wxAppCode) &#123; if (name.endsWith(\".wxss\")) &#123; handle.cssFile = path.resolve(frameName, \"..\", name); wxAppCode[name](); &#125; &#125;&#125; 再保存即可 参考来源反编译获取任何微信小程序源码(完)微信小程序编译包的获取与解压——在手机中获取小程序编译包wxapkg反编译微信小程序$gwx is not defined报错解决方法","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"Wechat Mini Program","slug":"Wechat-Mini-Program","permalink":"http://ldc5886.github.io/tags/Wechat-Mini-Program/"}],"author":"D橙"},{"title":"常见号码正则验证","slug":"常见号码正则验证","date":"2019-07-21T16:00:00.000Z","updated":"2019-10-13T14:18:36.762Z","comments":true,"path":"2019/07/22/常见号码正则验证/","link":"","permalink":"http://ldc5886.github.io/2019/07/22/%E5%B8%B8%E8%A7%81%E5%8F%B7%E7%A0%81%E6%AD%A3%E5%88%99%E9%AA%8C%E8%AF%81/","excerpt":"","text":"手机号码/^(13[0-9]|14[0-9]|15[0-9]|17[0-9]|18[0-9])\\d{8}$/ 身份证号码/^\\d{15}$|(^\\d{18}$)|(^\\d{17}(\\d|X|x))$/ 邮箱号码/^([a-zA-Z0-9_\\.\\-])+\\@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z0-9]{2,4})+$/","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"js","slug":"js","permalink":"http://ldc5886.github.io/tags/js/"},{"name":"regular","slug":"regular","permalink":"http://ldc5886.github.io/tags/regular/"}],"author":"D橙"},{"title":"html中控制文字间隔的方式","slug":"html中控制文字间隔的方式","date":"2019-07-21T16:00:00.000Z","updated":"2019-10-13T14:23:13.545Z","comments":true,"path":"2019/07/22/html中控制文字间隔的方式/","link":"","permalink":"http://ldc5886.github.io/2019/07/22/html%E4%B8%AD%E6%8E%A7%E5%88%B6%E6%96%87%E5%AD%97%E9%97%B4%E9%9A%94%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"使用空格HTML提供了5种空格实体（space entity），它们拥有不同的宽度，非断行空格（ ）是常规空格的宽度，可运行于所有主流浏览器。其他几种空格（ ‌‍）在不同浏览器中宽度各异。 &amp;nbsp; 它叫不换行空格，全称No-Break Space，它是按下空格键产生的空格。在HTML中，如果用空格键产生此空格，空格是不会累加的（只算1个）。要使用html实体表示才可累加， 该空格占据宽度受字体影响明显而强烈。 &amp;ensp; 它叫“半角空格”，全称是En Space，en是字体排印学的计量单位，为em宽度的一半。根据定义，它等同于字体度的一半（如16px字体中就是8px）。名义上是小写字母n的宽度。此空格传承空格家族一贯的特性：透明的，此空格有个相当稳健的特性 其占据的宽度正好是1/2个中文宽度，而且基本上不受字体影响。 &amp;emsp; 它叫“全角空格”，全称是Em Space，em是字体排印学的计量单位，相当于当前指定的点数。例如，1 em在16px的字体中就是16px。此空格也传承空格家族一贯的特性：透明的，此空格也有个相当稳健的特性， 就是其占据的宽度正好是1个中文宽度，而且基本上不受字体影响。 &amp;thinsp; 它叫窄空格，全称是Thin Space。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是em之六分之一宽。 &amp;zwnj; 它叫零宽不连字，全称是Zero Width Non Joiner，简称“ZWNJ”，是一个不打印字符，放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制。Unicode中的零宽不连字字符映射为“”（zero width non-joiner，U+200C），HTML字符值引用为： &#8204; &amp;zwj; 它叫零宽连字，全称是Zero Width Joiner，简称“ZWJ”，是一个不打印字符，放在某些需要复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果。零宽连字符的Unicode码位是U+200D (HTML: &#8205; &zwj;）。 此外，浏览器还会把以下字符当作空白进行解析：空格（&#x0020;）、制表位（&#x0009;）、换行（&#x000A;）和回车（&#x000D;）还有（&#12288;）等等。 CSSCSS中当 white-space 属性取值为pre时，浏览器会保留文本中的空格和换行,例如： 123&lt;div style=\"white-space:pre\"&gt;AA BB&lt;div&gt; 显示效果为： AA BB CSS的letter-spacing属性用于设置文本中字符之间的间隔，例如： 123&lt;div style=\"letter-spacing:5px;\"&gt;欢迎光临！&lt;/div&gt;显示效果为： 欢 迎 光 临 ！ CSS的word-spacing属性用于设置文本中单词之间的间隔，例如： 123&lt;div style=\"word-spacing:5px\"&gt;Happy new year!&lt;/div&gt; 显示效果为： Happy new year! ** word-spacing对中文文字是没有效果的，中文只能用letter-spacing ** 参考来源Html中的空格符HTML中空格的应用","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"html","slug":"html","permalink":"http://ldc5886.github.io/tags/html/"}],"author":"D橙"},{"title":"CSS hover失效的原因总结","slug":"CSS hover失效的原因总结","date":"2019-07-19T16:00:00.000Z","updated":"2019-10-13T14:27:17.633Z","comments":true,"path":"2019/07/20/CSS hover失效的原因总结/","link":"","permalink":"http://ldc5886.github.io/2019/07/20/CSS%20hover%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%80%BB%E7%BB%93/","excerpt":"最近碰到了一个设置h标签的hover失效问题，找了些资料，趁此机会做个总结","text":"最近碰到了一个设置h标签的hover失效问题，找了些资料，趁此机会做个总结 在 CSS 定义中，它们同时存在的时候,a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。,即visitied / link&gt; hover &gt; active ****在 CSS 定义中，它们同时存在的时候,a:active 必须被置于 a:hover 之后，才是有效的。 :hover 被置于 :link 和 :visited 之前类名写错了设置了hover的元素被其他元素覆盖住了自定义css覆盖优先级不够关于这方面的资料，参考CSS样式覆盖规则 hover:{}内部定义样式有错误存在hover和:和{}之间有空格存在或使用了中文冒号不只是hover，其他的link、focus等失效也同样有可能是因为这个点。 在设置:hover前加了空格,致使只对后代有效例如a :hover,该a标签本身不会有:hover的效果，而其后代元素才会有:hover的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style type=&quot;text/css&quot;&gt; .one &#123; margin: 0 auto; width: 400px; height: 300px; background: #ced05d; &#125; .two &#123; margin: 0 auto; width: 100px; height: 100px; background: #5a5aea; &#125; .three &#123; margin: 0 auto; width: 200px; height: 100px; background: #4b9c49; &#125; .four &#123; margin: 0 auto; width: 300px; height: 100px; background: #7b4141; &#125; .one :hover &#123; background: #da56d0; &#125;&lt;/style&gt;&lt;body&gt;&lt;h1&gt;测试&lt;/h1&gt;&lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;two&quot;&gt; &lt;/div&gt; &lt;div class=&quot;three&quot;&gt; &lt;/div&gt; &lt;div class=&quot;four&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 鼠标经过的时候，one的背景不变，而经过one里面的其他div背景颜色发生变化， hover只会与子代元素元素及兄弟元素起作用hover属性只作用于它的子代元素，并且自带设置属性（style、class、id）的子代元素不受hover的影响。 在做作业的过程中，会发现元素a会作用于自己不想要产生变化的元素，在这称为元素b，刚开始第一个想法就是将b与a分隔开，进而与a成为了兄弟元素，但有想要a:hover单独作用于b，这时发现代码a:hover .b{}失去了效果，通过查询资料了解到，当想要hover作用于兄弟元素时，代码会发生相应的变化，我们需要在b前加上+号，即a:hover +.b{}。但后面的过程又发现，这个方法并不是对所有的兄弟元素都适用，通过了解得知，hover作用的兄弟元素，仅仅只是对相邻的兄弟元素有用。 还是上个例子,把 123.one :hover &#123; background: #da56d0; &#125; 改为 123.one:hover .two &#123; background: #da56d0; &#125; 发现能达到我们想要的效果,改为 123.two:hover +.three &#123; background: #da56d0; &#125; 也能达到效果（注意把”+”号去掉，就不能达到效果了）,而改为 123.two:hover .four &#123; background: #da56d0; &#125; 不能达到我们的效果（无论带不带加号） IE下:hover无效时在页面中， 正确书写DOCTYPE，另外确保浏览器处于非兼容模式下 12&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd”&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; 参考文章：关于CSS中hover失效的几个原因css中关于hover失效问题总结关于hover失效的问题IE8下hover无效","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"error","slug":"error","permalink":"http://ldc5886.github.io/tags/error/"},{"name":"css","slug":"css","permalink":"http://ldc5886.github.io/tags/css/"}],"author":"D橙"},{"title":"CSS实现文字样式","slug":"CSS实现文字样式","date":"2019-07-17T16:00:00.000Z","updated":"2019-10-13T14:28:04.081Z","comments":true,"path":"2019/07/18/CSS实现文字样式/","link":"","permalink":"http://ldc5886.github.io/2019/07/18/CSS%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"CSS实现文字样式文字透明效果用rgba调整透明度或用opacity调整遮罩 123456.txt1&#123; background: pink; color: rgba(0,0,0,0.1); /*或*/ opacity: 0.1;&#125; 两种区别是用rgba只是对文字有透明度，而opacity对整个div都有遮罩影响，对比其两个div的背景颜色即可发现区别。 模糊文字在css中并没有指定文字模糊的样式，但是可以用text-shadow和-webkit-text-fill-color组合，得出模糊文字，即用text-shadow制造底层模糊文字，用-webkit-text-fill-color填充颜色为透明，例如： 1234.txt2 &#123; text-shadow: 0 0 5px red; -webkit-text-fill-color: transparent; &#125; 这里的text-shadow将x，y偏移量设置为0，也就是不偏移，设置味5px的模糊程度，重点是下面的fill-color设置为transparent透明，这样就把底层的模糊字体体现出来. 镂空文字这里我们用到-webkit-text-stroke来给文字外围描边，然后在把文字的填充颜色设置为透明，这样就能只显示出文字的外围的描边，也就是我们所说的镂空文字。 1234.txt3&#123; -webkit-text-stroke: 1px red; -webkit-text-fill-color: transparent; &#125; 渐变文字CSS中并没有给我们提供文字的渐变，但是我们的background可以做到渐变颜色，那怎么让文字渐变呢，我们上面的一个属性是让文字透明，这样文字底下的东西我们就可以看的到，那我们试想，如果让文字下面的渐变背景颜色显示出来，就是相当于文字有了背景颜色。这里虽然背景有了渐变，但文字直接成了透明，那么我们怎么做到文字外围的背景去除，文字中的背景显示出来，我们知道background-clip是用来设置背景图片在那个区域显示，如果它能让文字中的底下显示，那我们岂不是就能做到我们希望的效果～，没错-webkit-background-clip:text的效果就是指定背景只在文字底下显示. 12345.txt4&#123; background: linear-gradient(to bottom,blue,red); -webkit-text-fill-color: transparent; -webkit-background-clip: text;&#125; 图片背景文字我们都知道background-clip是用来设置背景图片的显示位置，如果要用到只在图片上显示背景位置，我们在这里用到了上面说的-webkit-background-clip: text,这个属性能让背景只在文字底下显示，如果文字设置为透明的，那我们就能透过文字，透过文字看到背景图片，这是一个能媲美PS效果的利器属性。 12345678910111213141516.txt5 &#123; /*背景样式*/ height: 300px; width: 500px; background-size: contain; background-repeat: no-repeat; background-image: url(img/bg1.jpg); /*文字样式*/ font-size: 70px; font-weight: bold; text-align: center; line-height: 300px; /*图片文字样式*/ -webkit-text-fill-color: transparent; -webkit-background-clip: text; &#125; css3 Animation 文字渐出效果12345678910111213141516171819@keyframes jianchu&#123; 0% &#123;opacity:0;&#125; 100% &#123;opacity:1;&#125;&#125;.div1 p&#123; font-family: Futura Bk BT; font-size: 7rem; color: #fff; white-space:pre; opacity:0; /*文字渐出效果 不兼容ie9及以下*/ animation: jianchu 5s ease 1s; animation-fill-mode:forwards; /* 兼容Safari 与 Chrome: */ -webkit-animation: jianchu 5s ease 1s; -webkit-animation-fill-mode:forwards;&#125;","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"css","slug":"css","permalink":"http://ldc5886.github.io/tags/css/"}],"author":"D橙"},{"title":"CSS样式优先级","slug":"CSS样式优先级","date":"2019-07-15T16:00:00.000Z","updated":"2019-10-13T14:22:34.522Z","comments":true,"path":"2019/07/16/CSS样式优先级/","link":"","permalink":"http://ldc5886.github.io/2019/07/16/CSS%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7/","excerpt":"","text":"关于CSS优先级一般情况下，优先级如下： 如果外部样式、内部样式和内联样式同时应用于同一个元素，就是使多重样式的情况时，优先级如下：（内联样式）Inline style &gt;（内部样式）Internal style sheet &gt;（外部样式）External style sheet 同一样式文件中，优先级由选择器的匹配规则来决定。内联 &gt; ID选择器 &gt; 伪类=属性选择器=类选择器 &gt; 元素选择器【p】 &gt; 通用选择器(*) &gt; 继承的样式 有个例外的情况，就是如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式 123456789101112&lt;style type=\"text/css\"&gt; /* 内部样式 */ h3&#123;color:green;&#125;&lt;/style&gt;&lt;!-- 外部样式 style.css --&gt; &lt;!-- 设置：h3&#123;color:blue;&#125; --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"/&gt;&lt;body&gt; &lt;h3&gt;测试！&lt;/h3&gt;&lt;/body&gt; 如何查看优先级浏览器打开开发者界面（F12），在Firebug中查看优先级。Firebug中按照优先级排序显示规则，将优先级更高的规则显示在最上面，并将被覆盖的规则用删除线划掉。 优先级的计算权重如图所示： Note: ID选择器「如：#header」，Class选择器「如：.foo」，属性选择器「如：[class]」，伪类「如：:link」，标签选择器「如：h1」，伪元素「如：:after」，选择器「*」 选择器都有一个权值，权值越大越优先； 当权值相等时，后出现的样式表设置要优于先出现的样式表设置； 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式； 继承的CSS 样式不如后来指定的CSS 样式； 在同一组属性设置中标有!important规则的优先级最大； 优先级计算无视DOM树中的距离1234567891011121314151617&lt;style type=\"text/css\"&gt; body h1 &#123; color: green; &#125; html h1 &#123; color: purple; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"further\"&gt; &lt;div id=\"close\"&gt; &lt;h1&gt;Here is a title!&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 因为css中优先级无视DOM树中节点的距离远近，因为body h1和html h1的优先级相同，都属于继承，离的近的优先级高，因此就算使用#close和#further来进行改变，文字也是绿色的。 伪类选择器，属性选择器和class选择器的优先级一样1234567891011121314151617181920&lt;style type=\"text/css\"&gt; :focus &#123; color: red; &#125; [class] &#123; color: blue; &#125; .classtest &#123; color: green; &#125;&lt;/style&gt;&lt;body&gt;&lt;div class=\"classtest\"&gt; 什么颜色文字&lt;/div&gt;&lt;/body&gt; 哪一个在最后，哪一个就生效！ 基于类型的优先级12345678910111213&lt;style type=\"text/css\"&gt;* #foo &#123; color: green;&#125;*[id=\"foo\"] &#123; color: purple;&#125;&lt;/style&gt;&lt;body&gt;&lt;p id=\"foo\"&gt;I am a sample text.&lt;/p&gt;&lt;/body&gt; 属性选择器尽管选择了一个ID但是在优先级计算中还是根据类型计算，因此即使选择的是相同的元素，但ID选择器有更高的优先级，所以* #foo设置的样式生效。 ：not伪类不参与优先级计算：not否定伪类在优先级计算中不会被看做是伪类，但是，会把:not里面的选择器当普通选择器计数。这句话有点不好理解，其实就是忽略掉:not，其他伪类(如:hover)参与CSS优先级的计算，但是:not不参与计算。 123456789101112131415161718192021&lt;style type=\"text/css\"&gt; div.outer p &#123; color:red; &#125; div:not(.outer) p &#123; color: blue; &#125;&lt;/style&gt;&lt;body&gt;&lt;div class=\"outer\"&gt; &lt;p&gt;This is in the outer div.&lt;/p&gt; &lt;div class=\"inner\"&gt; &lt;p&gt;This text is in the inner div.&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 选择器div.outer p和选择器div:not(.outer) p的优先级是相同的，:not被忽略掉了，:not(.outer)中的.outer正常计数。而如果调换位置，inner元素会变成红色。 !import不建议使用!import!!! Never 绝不要在全站使用!import。 Only 只在需要覆盖全站或外部 css（例如引用的 ExtJs 或者 YUI ）的特定页面中使用 !important Never 永远不要在你的插件中使用 !important Always 要优先考虑使用样式规则的优先级来解决问题而不是 !important 选择元素时尽量不要多选，不要放宽选择器的范围。因为范围越小，越具有针对性，优先级越高。 使用!import的场合在没有别的解决方案的时候。比如需要覆盖内联样式，因为内联样式的优先级最高，只能用!import去覆盖内联样式。还有一种情况 1234567891011121314151617&lt;style type=\"text/css\"&gt;#someElement p &#123; color: blue;&#125;p.awesome &#123; color: red;&#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"someElement\"&gt; &lt;p class=\"awesome\"&gt;some text&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 在外层有 #someElement 的情况下，你怎样能使 awesome 的段落变成红色呢？这种情况下，如果不使用 !important ，第一条规则永远比第二条的优先级更高。这也是没有别的办法，如果用内联结果只会更糟糕 覆盖已有的!import规则 再加一条!import的css语句，将其应用到更高优先级的选择器（在原有基础上添加额外的标签、类或者ID选择器）。 123table td &#123;height: 50px !important;&#125;.myTable td &#123;height: 50px !important;&#125;#myTable td &#123;height: 50px !important;&#125; 选择器一样，但添加的位置在原有声明后面。因为相同优先级，后边定义的声明覆盖前面的。 12td &#123;height: 30px !important;&#125;td &#123;height: 50px !important;&#125; 参考来源：深入理解css优先级CSS 的优先级机制总结","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"css","slug":"css","permalink":"http://ldc5886.github.io/tags/css/"}],"author":"D橙"},{"title":"关于浏览器默认的：focus样式","slug":"关于浏览器默认的：focus样式","date":"2019-07-15T16:00:00.000Z","updated":"2019-10-13T14:20:14.922Z","comments":true,"path":"2019/07/16/关于浏览器默认的：focus样式/","link":"","permalink":"http://ldc5886.github.io/2019/07/16/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E7%9A%84%EF%BC%9Afocus%E6%A0%B7%E5%BC%8F/","excerpt":"19.7.15碰到一个问题，使用bootstrap的下拉列表时，下拉的a标签点击后，总是会出现一个蓝色边框（移动端为黄色），查看了所有的css文件，都未发现有相关的语句，额外写的border也无法进行覆盖。后来经过反复查找，发现其实是浏览器默认的样式在起作用。","text":"19.7.15碰到一个问题，使用bootstrap的下拉列表时，下拉的a标签点击后，总是会出现一个蓝色边框（移动端为黄色），查看了所有的css文件，都未发现有相关的语句，额外写的border也无法进行覆盖。后来经过反复查找，发现其实是浏览器默认的样式在起作用。 outline当文本输入框（input、textarea）等元素获取了鼠标焦点（即:focus）时，谷歌(还有360)浏览器默认会给它们加上一个outline边框，尽管我们有时并不需要这边框。。。 （与border不同）outline边框轮廓线不会占据空间，它位于边框（border）边缘的外围，故而不会被border覆盖，可起到突出元素的作用 去除效果在CSS中用下面的代码去除该效果： 123元素名:focus &#123;outline: none;&#125; 去掉对应元素的焦点边框或*:focus &#123;outline: none;&#125; 去掉所有默认焦点边框 增加样式也可以给它来给元素增加边框样式：input,textarea:focus { outline:Blue Solid 4px; } 但使用时首先要先去掉默认的样式才行：input,textarea:focus {outline: none;} 关于该属性的更多了解可参考CSS outline 属性","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"css","slug":"css","permalink":"http://ldc5886.github.io/tags/css/"},{"name":"outline","slug":"outline","permalink":"http://ldc5886.github.io/tags/outline/"}],"author":"D橙"},{"title":"IE浏览器条件注释","slug":"IE浏览器条件注释","date":"2019-07-15T16:00:00.000Z","updated":"2019-10-13T14:24:29.025Z","comments":true,"path":"2019/07/16/IE浏览器条件注释/","link":"","permalink":"http://ldc5886.github.io/2019/07/16/IE%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9D%A1%E4%BB%B6%E6%B3%A8%E9%87%8A/","excerpt":"","text":"常用注释1234567891011121314151617181920212223&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;&lt;!--[if lte IE 6]&gt; IE6以及IE6以下版本可识别 （如IE5）&lt;![endif]--&gt;&lt;!--[if lt IE 6]&gt; IE6以下版本可识别(不包括IE6)&lt;![endif]--&gt;&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 （如IE7）&lt;![endif]--&gt;&lt;!--[if gt IE 6]&gt; IE6以上版本可识别(不包括IE6)&lt;![endif]--&gt; 运算符组合注释1234567891011&lt;!--[if !IE]&gt;&lt;!--&gt; 除IE外都可识别 &lt;!--&lt;![endif]--&gt;&lt;!--[if (gt IE 5)&amp;(lt IE 7)]&gt; 仅IE5以上和IE7版本以下可识别(不包括IE5和7)&lt;![endif]--&gt;&lt;!--[if (IE 6)|(IE 7)]&gt; 仅IE6和IE7版本可识别 &lt;![endif]--&gt;","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"compatible","slug":"compatible","permalink":"http://ldc5886.github.io/tags/compatible/"},{"name":"ie","slug":"ie","permalink":"http://ldc5886.github.io/tags/ie/"}],"author":"D橙"},{"title":"文字竖向排列","slug":"文字竖向排列","date":"2019-07-03T16:00:00.000Z","updated":"2019-10-13T14:13:04.458Z","comments":true,"path":"2019/07/04/文字竖向排列/","link":"","permalink":"http://ldc5886.github.io/2019/07/04/%E6%96%87%E5%AD%97%E7%AB%96%E5%90%91%E6%8E%92%E5%88%97/","excerpt":"","text":"超小白法将需要竖排显示的字符单独放在一个div或p等标签中，或放在span中然后在CSS中设置display属性为block实现竖排。 使用css1234567&lt;h1&gt; NETTUTS &lt;/h1&gt; &lt;div class=\"tow\"&gt;欲话毗陵君反袂&lt;/div&gt;&lt;div class=\"tow\"&gt;ENGLISH&lt;/div&gt;&lt;div class=\"one\"&gt;欲话毗陵君反袂，欲言夏口我沾衣。谁知临老相逢日，悲叹声多语笑稀。&lt;/div&gt; &lt;div class=\"one\"&gt;I AM ENGLISH&lt;/div&gt; 单句话竖向排列 (浏览器兼容性最好)在需要竖向显示的地方，强制定义显示区域的宽度，然后加宽字符间距这样字符会自动竖向排列 123456h1 &#123; width: 50px;font-size: 50px; word-wrap: break-word; /*英文的时候需要加上这句，自动换行,中文不需要，且浏览器兼容更好*/ letter-spacing: 20px; /*用于控制字符间距*/ &#125; 多个句子竖向排列（如古诗）123456.one &#123; margin: 0 auto; height: 140px; writing-mode: vertical-lr;/*从左向右 从右向左是 writing-mode: vertical-rl;*/ writing-mode: tb-lr;/*IE浏览器的从左向右 从右向左是 writing-mode: tb-rl；*/ &#125; 字体横行，整体竖向排版）1234567891011.tow &#123; margin: 150px auto; width: 200px; font-size: 20px; line-height: 24px; transform:rotate(90deg); -ms-transform:rotate(90deg); /* IE 9 */ -moz-transform:rotate(90deg); /* Firefox */ -webkit-transform:rotate(90deg); /* Safari 和 Chrome */ -o-transform:rotate(90deg); /* Opera */&#125; 使用js12var h1 = document.getElementsByTagName(‘h1′)[0]; h1.innerHTML = ‘&lt;span&gt;’ + h1.innerHTML.split(”).join(‘&lt;/span&gt;&lt;span&gt;’) + ‘&lt;/span&gt;’; 123&lt;style&gt; h1 span &#123; display: block; &#125; &lt;/style&gt; 此种方法与使用原理是一样的，好处是用js代替手工添加span标签。尽管如此，还是有一些弊端：a、当js失效的时候，会影响页面布局；b、当然完美的解决方法是，尽可能用css; 参考来源：CSS writing-mode 属性彻底搞懂word-break、word-wrap、white-space4种方法实现文字竖向排列CSS几种简单方法实现文字竖向排版","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"css","slug":"css","permalink":"http://ldc5886.github.io/tags/css/"}],"author":"D橙"},{"title":"清除float浮动的方式","slug":"清除float浮动的方式","date":"2019-07-01T16:00:00.000Z","updated":"2019-10-13T14:16:00.138Z","comments":true,"path":"2019/07/02/清除float浮动的方式/","link":"","permalink":"http://ldc5886.github.io/2019/07/02/%E6%B8%85%E9%99%A4float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"什么是浮动浮动的定义：使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来。 高度塌陷：浮动元素父元素高度自适应（父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷） after伪类 清浮动（万能清除法,主流,推荐使用）12345678选择符:after&#123; content:\".\"; clear:both; display:block; height:0; overflow:hidden; visibility:hidden; &#125; 同时为了兼容 IE6，7 同样需要配合zoom使用例如： 12.clear:after&#123;content:'';display:block;clear:both;height:0;overflow:hidden;visibility:hidden;&#125;.clear&#123;zoom:1;&#125; 需要注意的东西： 123456after伪类： 元素内部末尾添加内容； :after&#123;content&quot;添加的内容&quot;;&#125; IE6，7下不兼容zoom 缩放 a、触发 IE下 haslayout，使元素根据自身内容计算宽高。 b、Firefox 不支持； 添加空div用clear清除浮动 在浮动元素下方添加空div,并给该元素写css样式 123clear:both;height:0;overflow:hidden; 给浮动元素父级设置高度我们知道高度塌陷是父级高度自适应导致的，那么我们给它的设置适当的高度就可以解决这个问题了。 缺点：在浮动元素高度不确定的时候不适用 以浮制浮父级同时给浮动 缺点：需要给每个浮动元素父级添加浮动，浮动多了容易出现问题。 父级设置成inline-block缺点：父级的margin左右auto失效，无法使用margin: 0 auto;居中了 br 清浮动1234&lt;div class=\"box\"&gt; &lt;div class=\"top\"&gt;&lt;/div&gt; &lt;br clear=\"both\" /&gt;&lt;/div&gt; br 标签自带clear属性，将它设置成both其实和添加空div原理是一样的。缺点：不符合工作中：结构、样式、行为，三者分离的要求。 给父级添加overflow:hidden 清浮动方法；缺点：需要配合 宽度 或者 zoom 兼容IE6 IE7； 12overflow: hidden;*zoom: 1; 参考来源：css清除浮动float的七种常用方法总结和兼容性处理","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"css","slug":"css","permalink":"http://ldc5886.github.io/tags/css/"}],"author":"D橙"},{"title":"一些关于http协议的问题","slug":"一些关于http协议的问题","date":"2019-06-25T16:00:00.000Z","updated":"2019-10-13T14:30:57.587Z","comments":true,"path":"2019/06/26/一些关于http协议的问题/","link":"","permalink":"http://ldc5886.github.io/2019/06/26/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8Ehttp%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"HTTP协议用于客户端与服务端之间的通信（应用HTTP协议，必定有一端是客户端，另一端是服务器端），HTTP是一个应用层协议，虽然在2015年已推出HTTP/2版本，并被主要的web浏览器和web服务器支持。但目前使用最广泛的还是HTTP/1.1版本。","text":"HTTP协议用于客户端与服务端之间的通信（应用HTTP协议，必定有一端是客户端，另一端是服务器端），HTTP是一个应用层协议，虽然在2015年已推出HTTP/2版本，并被主要的web浏览器和web服务器支持。但目前使用最广泛的还是HTTP/1.1版本。 参考HTTP请求头部+响应码HTTP协议报文解析 http请求报文结构都包含什么请求头、请求行、请求实体、 123456789101112//请求头 包含了请求方法、请求资源路径、HTTP协议版本 GET(POST) /mini.png HTTP/1.1 //请求行 请求首部字段 Host:120.25.226.186:32812 客户端想访问的服务器主机地址 User-Agent:Mozilla/5.0 客户端的类型，客户端的软件环境 Accept:text/html 客户端所能接收的数据类型 Accept-Language：zh-cn 客户端的语言环境 Accept-Encoding：gzip 客户端支持的数据压缩格式 //请求实体 内容实体 name=user&amp;ag=12 http协议常用的状态码200 – （成功） 服务器成功返回网页304 – （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。404 – （未找到） 服务器找不到请求的网页。503 – （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 http头部关于缓存的字段HTTP控制缓存的字段主要包括Cache-Control/Pragma这个HTTP Head字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令，如果知道该页面是否为缓存，不仅可以控制浏览器，还可以控制和HTTP相关的缓存或代理服务器。它可以指定下列可选值：1、Public：所有内容都将被缓存，在响应头中设置2、Private：内容只缓存在私有缓存中，在响应头中设置3、no-cache：所有内容都不会被缓存，在请求头和响应头中设置4、no-store：所有内容都不会被缓存在缓存或Internet临时文件中，在响应头中设置5、must-revalidation/proxy-revalidation：如果缓存的内容失效，请求必须发送到服务 器/代理以进行重新验证，在请求头中设置6、max-age=xxx：缓存的内容将在xxx秒后失效，这个选项只在HTTP1.1中可用，和Last-Modified一起使用时优先级较高，在响应头中设置 (最常用的)Cache-Control请求字段可以被个浏览器很好的支持，而且优先级也比较高，它和其他一些请求字段（如Expires）同时使用时，Cache-Control会覆盖其他字段 Pragma字段的作用和Cache-Control类似， Pragma:no-cache，他和Cache-cache的作用是一致的。ExpiresExpires通常的使用格式是Expires:Sat,25 Feb 2012 12:22:17 GMT,后面跟着一个日期和时间，超过这个时间后，缓存的内容将失效，浏览器在发送请求之前检查这个页面的字段，看该页面是否已经过期了，如果过期，就向服务端重新发起请求。 Last-Modified/Etag。Last-Modified字段一般用于表示一个服务器上的资源的最后修改时间，资源可以是静态资源，也可以是动态内容，通过这个最后修改时间可以判断当前请求的资源是否是最新的。 一般服务端会在响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间，如Last-Modified:Sat, 25 Feb 2012 12:55:04 GMT,浏览器再次请求时在请求头中增加If-Modified-Since:Sat, 25 Feb 2012 12:55:04 GMT字段，询问当前缓存的页面是否是最新。如果是最新的就返回304，告诉浏览器是最新的，服务器也不会传输最新的数据 Etag字段的作用和LastModified字段作用相同，这个字段的作用是让服务端给每个页面分配一个唯一的编号，然后通过这个编号来区分当前页面是否最新。这种方式比较灵活，但是当后端的服务器有多台时比较难以处理。 下图为一个实例 http和https的区别https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式用的端口也不一样，前者是80，后者是443。 HTTP连接是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，安全性高于HTTP协议。 http1.0 1.1 2 大致的区别…….. 除此之外暂时想不到其他的了。缓存字段和200、404、304之类非常常用的状态码一定要记住。","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"http","slug":"http","permalink":"http://ldc5886.github.io/tags/http/"}],"author":"D橙"},{"title":"前端工程化、模块化、组件化概念","slug":"前端工程化、模块化、组件化概念","date":"2019-06-25T16:00:00.000Z","updated":"2019-10-13T14:31:39.137Z","comments":true,"path":"2019/06/26/前端工程化、模块化、组件化概念/","link":"","permalink":"http://ldc5886.github.io/2019/06/26/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E6%A6%82%E5%BF%B5/","excerpt":"前端工程化、模块化、组件化概念浅浅浅浅析","text":"前端工程化、模块化、组件化概念浅浅浅浅析 前端工程化还记得我在最早期写前端代码时,往往一个页面就是一个文件搞定,HTML/CSS/JS全部写在一起,后来知道应该把结构、样式和动作分离,我想这是我接触到最早的前端工程化的思想了,所谓前端工程化我认为就是将前端项目当成一项系统工程进行分析、组织和构建从而达到项目结构清晰、分工明确、团队配合默契、开发效率提高的目的. 工程化是一种思想而不是某种技术(当然为了实现工程化我们会用一些技术),所谓前端工程化就是将前端项目当成一项系统工程进行分析、组织和构建从而达到项目结构清晰、分工明确、团队配合默契、开发效率提高的目的。而模块化和组件化是为工程化思想下相对较具体的开发方式，因此可以简单的认为模块化和组件化是工程化的表现形式。这样说还不够具体,举个例子来说:要盖一栋大楼,假如我们不进行工程化的考量那就是一上来掂起瓦刀、砖块就开干,直到把大楼垒起来,这样做往往意味着中间会出现错误,要推倒重来或是盖好以后结构有问题但又不知道出现在哪谁的责任甚至会在某一天轰然倒塌,那我们如果用工程化的思想去做,就会先画图纸、确定结构、确定用料和预算以及工期,另外需要用到什么工种多少人等等,我们会先打地基再建框架再填充墙体这样最后建立起来的高楼才是稳固的合规的,什么地方出了问题我们也能找到源头和负责人。 前面我说接触最早的工程化思维就是“结构、样式和动作分离”,在只有若干个页面的小型项目我们只需要用这些简单的做法就能把项目很好的组织起来,但是在一个大型web项目中往往有更加复杂的结构和非常多的页面需要很多人甚至是多个团队配合才能把项目做完,我们需要有更加严谨和复杂的工程化思维去组织结构。从更高层面的项目组织来看我们要做项目的各种规范、技术选型、项目构建优化等等,在代码层面我们还需要用到JS/CSS模块机、UI组件化等开发方式。 再用一句通俗的话来概括前端工程化:前端工程化就是用做工程的思维看待和开发自己的项目,而不再是直接撸起袖子一个页面一个页面开写 前端工程化分为三个大阶段 技术选型：库/框架选型 简单构建优化：选型之后基本上就可以开始敲码了，不过光解决开发效率还不够，必须要兼顾运行性能。前端工程进行到第二阶段会选型一种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并。 JS/CSS模块化开发： JS模块化方案很多，AMD/CommonJS/UMD/ES6 Module等，对应的框架和工具也一大堆，说起来很烦，大家自行百度吧；CSS模块化开发基本都是在less、sass、stylus等预处理器的import/mixin特性支持下实现的。 前端模块化前面我们提到在组织代码的时候会用到模块化和组件化,大家应该理解到,前端工程化是一个高层次的思想,而模块化和组件化是为工程化思想下相对较具体的开发方式,因此可以简单的认为模块化和组件化是工程化的表现形式。 那具体什么是模块化呢,还是举简单的例子,我们要写一个实现A功能的JS代码,这个功能在项目其他位置也需要用到,那么我们就可以把这个功能看成一个模块采用一定的方式进行模块化编写,既能实现复用还可以分而治之,同理在写样式的时候,如果我们需要某种特殊的样式,会在很多地方应用,那么我们也可以采用一定的方式进行CSS的模块化,具体说来,JS模块化方案很多有AMD/CommonJS/UMD/ES6 Module等,CSS模块化开发大多是在less、sass、stylus等预处理器的import/mixin特性支持下实现的,具体技术大家自行学习。 三种模块化规范 CommonJS 根据 CommonJS 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。 AMD AMD 即 Asynchronous Module Definition，中文名是异步模块定义的意思。AMD规范通过 define 方法去定义模块，通过require方法去加载模块。RequireJS 实现了这种规范。 CMD CMD 即 Common Module Definition 通用模块定义，是 SeaJS 在推广过程中对模块定义的规范化产出。 模块化规范： https://blog.csdn.net/fu983531588/article/details/89309242 前端组件化前文中我们提到过,组件化也是工程化的表现形式,那么到底什么是前端组件化呢①页面上的每个独立的、可视/可交互区域视为一个组件;②每个组件对应一个工程目录,组件所需的各种资源都在这个目录下就近维护;③由于组件具有独立性,因此组件与组件之间可以 自由组合;④页面只不过是组件的容器,负责组合组件形成功能完整的界面;⑤当不需要某个组件,或者想要替换组件时,可以整个目录删除/替换。 组件化将页面视为一个容器,页面上各个独立部分例如:头部、导航、焦点图、侧边栏、底部等视为独立组件,不同的页面根据内容的需要,去盛放相关组件即可组成完整的页面。 PS:模块化和组件化一个最直接的好处就是复用,同时我们也应该有一个理念,模块化和组件化除了复用之外还有就是分治,我们能够在不影响其他代码的情况下按需修改某一独立的模块或是组件,因此很多地方我们及时没有很强烈的复用需要也可以根据分治需求进行模块化或组件化开发。","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"optimization","slug":"optimization","permalink":"http://ldc5886.github.io/tags/optimization/"}],"author":"D橙"},{"title":"关于性能优化方案","slug":"关于性能优化方案","date":"2019-06-25T16:00:00.000Z","updated":"2019-10-13T14:30:01.785Z","comments":true,"path":"2019/06/26/关于性能优化方案/","link":"","permalink":"http://ldc5886.github.io/2019/06/26/%E5%85%B3%E4%BA%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/","excerpt":"首先，减少HTTP请求次数，比如说合并CSS和JS文件，但是也不要完全的合并在同一个文件里面，一个域名分散三四个资源，这样方便浏览器去并行下载，当然浏览器对每个域名的并行下载个数有限制，一个域名分配三四个资源虽然增加了HTTP请求数量，但是对比并行下载来说，性价比更高。 可以使用webpack使用进行减少js文件的体积，可以使用babel-plugin-import、babel-plugin-component、webpack.ContextReplacementPlugin、webpack.IgnorePlugin…","text":"首先，减少HTTP请求次数，比如说合并CSS和JS文件，但是也不要完全的合并在同一个文件里面，一个域名分散三四个资源，这样方便浏览器去并行下载，当然浏览器对每个域名的并行下载个数有限制，一个域名分配三四个资源虽然增加了HTTP请求数量，但是对比并行下载来说，性价比更高。 可以使用webpack使用进行减少js文件的体积，可以使用babel-plugin-import、babel-plugin-component、webpack.ContextReplacementPlugin、webpack.IgnorePlugin… 提升Web性能的8个技巧总结 管理“页面膨胀” 页面大小与性能有着密切的关系。Radware 最新电商性能“行业现状”报告显示，100 强电商页面大小中位数达到了 1492KB，比一年半之前增大了 48%。 在研究报告里加载最快的 10 个页面中，页面包含的资源请求中位数为 50 个，页面大小中位数为 556KB。而加载最慢的 10 个页面中，页面包含的资源请求中位数为 141 个，页面大小中位数为 3289KB。换句话说，加载最慢的页面的资源中位数几乎是加载最快的页面的三倍，页面大小则是六倍。 仔细研究页面尺寸大小，我们可以得到更多的信息。加载最快的 10 个页面所包含的资源总数范围比较密集：在 15 个72 个之间;页面尺寸最小的仅为 251KB，最大的 2003KB。而加载最慢的 10 个页面所包含的资源总数范围则比较广泛：在 89 个373 个之间;页面尺寸最小为 2073KB，最大的则超过了 10MB。 进行图像优化 进行图像优化是提升性能最简单的一种方法，它可以使页面加载更快。为了更有效的完成图像渲染，图像必须经过压缩和整合、图像的尺寸和格式必须经过仔细调整，图像质量也必须经过优化，这样才可以依据图像的重要性进行区别化的加载处理。 控制第三方脚本 在典型的页面服务器请求中，来自于第三方脚本的请求占了其中的 50% 或更多。这些第三方脚本不仅会增加页面的字节数，带来延迟，而且也会成为 Web 页面中最大的潜在故障点。无响应、未经优化的第三方脚本会降低整个网络的加载速度。 解决办法是延迟第三方脚本的加载，将其放在关键页面内容之后进行加载，更为理想的情况是放在页面 onLoad 事件之后加载，这样才不会影响企业的搜索排名(谷歌将 onLoad 事件作为加载时间指标)。对于一些分析工具和第三方广告商而言，如果延迟第三方脚本加载的方法不可行，可以利用脚本的异步版本，与关键内容的加载同步进行。用户必须了解网站中有哪些脚本，删除那些无用的脚本，并对第三方脚本的性能进行持续监控。 真正做到移动设备优先 “移动设备优先”并不是一个全新的概念。早在 2013 年，移动设备的使用量就已经超过了台式机，然而与众多口头承诺的移动性能相比，真正专注于移动设备的开发还是存在一定的差距。例如，2011 年 11 月，移动设备上的平均页面大小为 475KB，现在则增长至 897 KB。也就是说，在短短三年之间，平均页面大小几乎翻了一番。 尽管移动设备和网络取得了一些进展，但就性能而言，还是无法与大小已接近 1MB 的服务页面需求保持同步。我们知道，页面大小与加载时间息息相关，移动用户对缓慢的加载速度尤其敏感。如果企业希望网站可以真正做到“移动设备优先”，就必须正确处理这些问题。 在进行响应式 Web 设计时兼顾性能 响应式设计让设计人员和开发人员可以更好地控制 Web 页面的外观和感觉。它可以使跨多平台和设备上的页面变得更漂亮。但同时也会带来巨大的性能损失，这些性能损失并不能通过更快速的浏览器、网络和小工具得到缓解。而且随着时间的推移，这样影响还将持续恶化。 响应式设计建立在样式表和 JavaScript 之上。然而，低效的 CSS 和 JS 所带来的性能问题远远大于其设计优势给我们带来的好处。样式表应当放在 HEAD 文档中，用以实现页面的逐步渲染。JavaScript 文件应当放在页面底部或在关键内容加载完成之后再被加载才是合理的处理方式。 实时监控性能 大家都知道要解决一个问题就必须先对问题有充分的了解。要解决页面性能问题，企业就必须知道用户在什么时候可以看到主要页面内容并与之进行交互;同时，企业还需了解性能和可用性问题是如何影响业务指标的。企业需要有方法获取实际的性能指标并对其进行分析。实时用户监控(RUM)工具可以从真实用户的角度实时获取、分析并记录网站的性能和可用性。 切勿过分依赖 CDN 解决所有性能问题 Radware 季度电商性能“行业现状”报告中存在一项最具争议性的调查结果，即：使用内容分发网络(CDN)的网站完成主要内容渲染所需的时间比未曾使用 CDN 的网站要长的多。这是一个相关性问题，而非因果关系：通常情况下，相较于未使用 CDN 的网站，使用 CDN 的网站页面更大，也更复杂。页面的大小和复杂程度才是造成性能问题的元凶，而非 CDN。但这一结果也表明，仅依靠 CDN 并不能解决所有的性能难题。 如果部署得当，CDN 会是解决延迟问题非常有效的工具：缩短托管服务器接收、处理并响应图像、CSS 文件等页面资源请求所需的时间。但是，延迟仅仅只是现代电商网站的关键问题之一。为了实现最佳的加速效果，网站运营人员可以采用组合解决方案：CDN+ 前端优化(如 Radware FastView 解决方案)+应用交付控制器(ADC)和内部管理。 在企业内部加强 Web 性能观念的宣传 大量研究证明，提高页面速度可以对所有的关键性能指标产生积极影响：页面访问量、用户粘连度、业务转化率、用户满意度、客户保持、购物车的内容多少和收入。 然而，正如上述 7 个建议中所表明的那样，许多企业都犯了同样的错误，最终损害了 Web 性能。目前，企业应该重点解决 Web 开发目标和在线业务目标之间的差距问题，而且，每个企业都应该至少拥有一个内部性能专家，以便更好的解决 Web 性能问题。 一、html方面1.缩小favicon.ico并缓存； 2.样式放在页头，JS放在页尾； 3.减少DOM节点：加速页面渲染； 4.用LINK而不用@import方式导入样式； 5.给图片加上正确的宽高值：这可以减少页面重绘，同时防止图片缩放； 6.链接为目录或首页的地址后面加”/”，如http://www.kokojia.com/； 7.正确的闭合标签：如避免使用，浏览器会多一个将它解析成&lt;div\\&gt;的过程； 8.语义化HTML：好处在于可以使代码简洁清晰，支持不同设备，利于搜索引擎，便于团队开发； 9.防止src属性和link的href属性为空：当值为空时，浏览器很可能会把当前页面当成其属性值加载。 二、css方面1.删除重复的CSS； 2.使用CSS缩写，减少代码量； 3.避免使用CSS Filter（CSS滤镜）； 4.减少查询范围：如.header&gt;li要好过.headerli； 5.通过CSS Sprites把同类图片合成一张，减少图片请求； 6.减少查询层级：如.header.logo要好过.header.top.logo； 7.避免TAG标签与CLASS或ID并存：如a.top、button#submit； 8.避免使用CSS Expressions(CSS表达式)：如background-color:expression((newDate()).getHours()%2?“#B8D4FF”:“#F08A00″)。 三、Javscript方面1.不使用EVAL； 2.删除重复的JS； 3.尽量少用全局变量； 4.避免频繁操作DOM节点； 5.使用事件代理绑定事件，如将事件绑定在body上进行代理； 6.对字符串进行循环操作，譬如替换、查找，应使用正则表达式； 7.减少对象查找，如a.b.c.d这种查找方式非常耗性能，尽可能把它定义在变量里； 8.类型转换：把数字转换成字符串使用“+1”，浮点数转换成整型使用Math.floor()或者Math.round()。 四、服务器方面1.使用gzip压缩内容； 2.压缩CSS、JS文件，缩短文件传输时间； 3.为文件头指定Expires，使内容具有缓存性。 4.使用CDN加速，使用户从离自己最近的服务器下载文件； 5.尽量合并CSS、JS文件，或将其直接写在页面上，减少HTTP请求； 6.避免404错误：特别要避免给404指定一个停摆页面，否则所有404错误都将会加载一次页面； 7.减少Cookie的大小，使用无cookie的域，客户端请求静态文件的时候，减少Cookie的反复传输对主域名的影响； 8.一般要求减少DNS查询次数，如同一个页面的请求资源要尽量少的使用不同的主机名，可以减少网站并行下载的数量。但很多网站为了加速下载资源其实是特意用了多个主机名，这里要做一个权衡。","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"optimization","slug":"optimization","permalink":"http://ldc5886.github.io/tags/optimization/"}],"author":"D橙"},{"title":"JS for循环内报错","slug":"JS for循环内报错","date":"2019-06-25T16:00:00.000Z","updated":"2019-10-13T14:26:28.105Z","comments":true,"path":"2019/06/26/JS for循环内报错/","link":"","permalink":"http://ldc5886.github.io/2019/06/26/JS%20for%E5%BE%AA%E7%8E%AF%E5%86%85%E6%8A%A5%E9%94%99/","excerpt":"for循环内嵌套onclick点击事件时只输出的最后的值问题及解决方案","text":"for循环内嵌套onclick点击事件时只输出的最后的值问题及解决方案 利用for循环给每一个li添加点击后改变颜色的事件，但结果是只有最后一个li添加上了，其余的li都未添加上 报错信息Uncaught TypeError:Cannot set property ‘style’ of undefined 123456var lis = document.getElementByTagName(\"li\");for(var i=0; len=lis.lenth,i&lt;len; i++) &#123; list[i].onclick = function() &#123; lis[i].style.backgroundColor = \"red\"; &#125;&#125; 报错分析该问题实际涉及了事件绑定、普通事件、for循环等多个知识点。js代码从上自下，执行完毕后，li的onclick还没有触发，for循环已经转完！！！而for循环没有自己的作用域！所以循环多次时，用的是同一个全局变量i！也就是在for循环转完后，这个全局变量已经变成了lis.lenth，所以点击触发事件时，才会只有lis.lenth表示的最后一个li成功，最后改进代码为 123456789let lis = document.getElementByTagName(\"li\");function foo()&#123; for(let i=0; len=lis.lenth,i&lt;len; i++) &#123; list[i].onclick = function() &#123; lis[i].style.backgroundColor = \"red\"; &#125; &#125;&#125;;foo(); 深入了解JS中的作用域以及全局变量的问题 JS在for循环中绑定事件的失效问题","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"error","slug":"error","permalink":"http://ldc5886.github.io/tags/error/"},{"name":"js","slug":"js","permalink":"http://ldc5886.github.io/tags/js/"}],"author":"D橙"},{"title":"Vue-Router动态路由复用组件时的响应方式","slug":"Vue-Router动态路由复用组件时的响应方式","date":"2019-06-14T16:00:00.000Z","updated":"2019-10-13T14:33:21.473Z","comments":true,"path":"2019/06/15/Vue-Router动态路由复用组件时的响应方式/","link":"","permalink":"http://ldc5886.github.io/2019/06/15/Vue-Router%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%A4%8D%E7%94%A8%E7%BB%84%E4%BB%B6%E6%97%B6%E7%9A%84%E5%93%8D%E5%BA%94%E6%96%B9%E5%BC%8F/","excerpt":"使用Vue-Router动态路由复用组件时，对于无法使用组件的生命周期钩子来请求数据的解决方式","text":"使用Vue-Router动态路由复用组件时，对于无法使用组件的生命周期钩子来请求数据的解决方式 问题描述以代码为例,我有一个 article 组件，对于所有 page 各不相同的用户，全都映射到这个组件中渲染。 1234567891011&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;router-link :to=\"&#123;name:'articlelink',params:&#123;page:'1'&#125;&#125;\"&gt; 文章1 &lt;/router-link&gt; &lt;router-link :to=\"&#123;name:'articlelink',params:&#123;page:'2'&#125;&#125;\"&gt; 文章2 &lt;/router-link&gt; &lt;router-link :to=\"&#123;name:'articlelink',params:&#123;page:'3'&#125;&#125;\"&gt; 文章3 &lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 我在vue-router的路由路径中使用“动态路径参数”来达到这个效果（一个“路径参数”使用冒号: 标记，如:page,使其成为一个变量。当匹配到一个路由时，参数值会被设置到this.$route.params，可以在每个组件内使用。于是，我们可以更新 article 的模板，输出当前page） 1234567891011121314151617181920212223let article = &#123; template: '&lt;div&gt;我是第 &#123;&#123;$router.params.page&#125;&#125; 篇文章&lt;/div&gt;' ; created()&#123; alert('发起请求获取第'+ this.$router.params.page +'的数据') &#125;&#125;//路由和组件的映射表let routes = [ &#123; path: '/article/:page',name:'articlelink', component: article &#125;]//实例化路由对象const router = new VueRouter(&#123; routes: routes&#125;)const app = new Vue(&#123; el:'#app', router,&#125;) 但这里有一个问题，当使用路由参数时，例如从 /article/1 导航到 /article/2，原来的组件实例会被复用。虽然两个路由都渲染同个组件，显得更加高效。但也由于组件组件实例是被复用，不是重创建的，因此其内的生命周期钩子created不会再被调用，造成无法更新数据的情况。 解决方式一 watch 监测变化vue-router官网给出的解决的方式是在复用组件时，使用 watch 监测 $route 对象，从而对路由参数的变化作出响应。如 123456789let article = &#123; template: '&lt;div&gt;我是第 &#123;&#123;$router.params.page&#125;&#125; 篇文章&lt;/div&gt;' ; watch:&#123; $router()&#123; alert('发起请求获取第'+ this.$router.params.page +'的数据') &#125; &#125;&#125; 解决方式二 给router-view加key值可以给router-view绑定一个随机key值，如&lt;router-view :key=&quot;Math.random()&quot;&gt;&lt;/router-view&gt;，从而使得每一次调用article时，由于key不同，都会重新创建，从而仍可以使用created钩子来请求数据。","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://ldc5886.github.io/tags/vue/"}],"author":"D橙"},{"title":"uni-app setTimeout函数实机测试无效","slug":"uni-app setTimeout函数实机测试无效","date":"2019-06-12T16:00:00.000Z","updated":"2019-10-13T14:46:40.754Z","comments":true,"path":"2019/06/13/uni-app setTimeout函数实机测试无效/","link":"","permalink":"http://ldc5886.github.io/2019/06/13/uni-app%20setTimeout%E5%87%BD%E6%95%B0%E5%AE%9E%E6%9C%BA%E6%B5%8B%E8%AF%95%E6%97%A0%E6%95%88/","excerpt":"setTimeout函数实机测试无效","text":"setTimeout函数实机测试无效 报错信息无报错，但setTimeout实机测试无效 1234567methods: &#123; begin:function ()&#123; //设置2s后跳转 setTimeout(\"uni.navigateTo(&#123;url: '../show/show',animationType: 'pop-in',animationDuration: 200&#125;)\", 2000); &#125; &#125; 报错分析在uni-app中setTimeout的函数写法与原生JS中的写法略有不同，使用原生的写法不会报错，但该写法会不起作用 在uni-app中的正确写法 123456789methods: &#123; begin:function ()&#123; setTimeout(function () &#123; uni.navigateTo(&#123;url: '../show/show',animationType: 'pop-in',animationDuration: 200&#125;); &#125;, 2000); &#125; &#125; 可参考uni官方文档","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"error","slug":"error","permalink":"http://ldc5886.github.io/tags/error/"},{"name":"uni-app","slug":"uni-app","permalink":"http://ldc5886.github.io/tags/uni-app/"}],"author":"D橙"},{"title":"JS 跨域","slug":"JS 跨域","date":"2019-05-31T16:00:00.000Z","updated":"2019-10-13T14:36:46.964Z","comments":true,"path":"2019/06/01/JS 跨域/","link":"","permalink":"http://ldc5886.github.io/2019/06/01/JS%20%E8%B7%A8%E5%9F%9F/","excerpt":"要考察对web安全是否有接触 ，关于安全方面的在面试时是经常被问到的。同一个意思可能问法也不同，比如说：“你对跨域了解吗？”“什么是跨域请求了？”其实都是同一个意思，回答思路可以先回答什么是跨域请求，有什么方式可以实现跨域请求基本上就可以了。","text":"要考察对web安全是否有接触 ，关于安全方面的在面试时是经常被问到的。同一个意思可能问法也不同，比如说：“你对跨域了解吗？”“什么是跨域请求了？”其实都是同一个意思，回答思路可以先回答什么是跨域请求，有什么方式可以实现跨域请求基本上就可以了。 为什么要跨域？跨域问题是浏览器同源策略限制，基于JS的安全，JS同源策略要求一个网站不能调用其它网站的js对象，本域的js不能操作其他域的页面对象（比如DOM），当前域名的js只能读取同域下的窗口（iframe）属性。 安全限制的同时也给注入iframe或是ajax应用带来了不少麻烦。所以我们要通过一些方法使得本域的js能够操作其他域的页面对象，或者其他域的js能操作本域的页面对象（iframe之间）。 这里需要明确的一点是：所谓的域跟js的存放服务器没有关系，比如baidu.com的页面加载了google.com的js，那么此js的所在域是baidu.com而不是google.com。也就是说，此时该js能操作baidu.com的页面对象，而不能操作google.com的页面对象。 一个网站的网址组成包括协议名，子域名，主域名，端口号。比如https://www.github.com/80，其中https是协议名，www.github.com是子域名，github.com是主域名，端口号是80，当在在页面中从一个url请求数据时，如果这个url的协议名、子域名、主域名、端口号任意一个有一个不同，就会产生跨域请求。 特别注意： 如果是协议和端口造成的跨域问题“前台”是无能为力的， 在跨域问题上，域仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名 和 端口 必须匹配”。跨域方式小结使用JSONP跨域（跨全域）JSONP的请求过程： 请求阶段：浏览器创建一个 script 标签，并给其src 赋值(类似 http://example.com/api/?callback=jsonpCallback ）。发送请求：当给script的src赋值时，浏览器就会发起一个请求。数据响应：服务端将要返回的数据作为参数和函数名称拼接在一起(格式类似jsonpCallback({name: &#39;abc&#39;}))返回。当浏览器接收到了响应数据，由于发起请求的是 script，所以相当于直接调用 jsonpCallback方法，并且传入了一个参数。 优点：它不像XMLHttpRequest对象实现 Ajax 请求那样受到同源策略的限制,兼容性好，在很古老的浏览器中也可以很好的运行,不需要XMLHttpRequest或ActiveX的支持，简单易用，支持浏览器与服务器双向通信。 缺点：只支持GET请求，且只支持跨域HTTP请求这种情况（不支持HTTPS）.不能很好的发现错误，并进行处理。与 Ajax 对比，由于不是通过 XmlHttpRequest 进行传输，所以不能注册 success、 error 等事件监听函数,不能解决不同域的两个页面或 iframe 之间进行数据通信的问题。 情景：网站http://localhost:63342/页面要请求http://localhost:3000/users/userlist页面，userlist页面返回json字符串{name: &#39;Mr.Cao&#39;, gender: &#39;male&#39;, career: &#39;IT Education&#39;} 端口号为63342网站的一个页面index.html通过ajax请求url http://localhost:3000/users/userlist ，这个明显的出现了跨域请求，因为端口号不一样。请求时就会报错 解决方式，采用JSONP方式来请求index.html使用 jQuery 集成的 $.ajax实现 JSONP 跨域调用 端口号为63342网站的页面 12345678910&lt;script&gt; $.ajax(&#123; url:\"http://localhost:3000\", type:\"get\", dataType:\"jsonp\", success:function(e)&#123; console.log(e); &#125; &#125;);&lt;/script&gt; Node.js 服务器代码 1234567891011121314151617//运行node server即可建立服务const url = require('url'); require('http').createServer((req, res) =&gt; &#123; const data = &#123; name: 'Mr.Cao', gender: 'male', career: 'IT Education' &#125;; const callback = url.parse(req.url, true).query.callback; res.writeHead(200); res.end(`$&#123;callback&#125;($&#123;JSON.stringify(data)&#125;)`); //最关键的一步，拼接回调函数和作为函数参数的数据data&#125;).listen(3000, '127.0.0.1');console.log('启动服务，监听 127.0.0.1:3000'); 这里一定要注意JSON 的格式转换，不能直接将 JSON 格式的数据直接传给回调函数，否则会发生编译错误： parsererror Error: jsonpCallback was not called。 使用 script 标签原生实现 JSONPNodejs 服务器代码同上 端口号为63342网站的页面 1234567script&gt;function jsonpCallback(data) &#123; alert('已获得数据:' + data); console.log(data);&#125;/script&gt;script src=\"http://127.0.0.1:3000?callback=jsonpCallback\"&gt;&lt;/script&gt; 由于实现的原理不同，由 JSONP 实现的跨域调用不是通过 XmlHttpRequset 对象，而是通过 script 标签，所以在实现原理上，JSONP 和 Ajax 已经一点关系都没有了。看上去形式相似只是由于 jQuery 对 JSONP 做了封装和转换，实质上jQuery使用也还是script标签的实现方式。 后端使用 CORS 实现跨域调用（跨全域）原理：CORS的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 ajax 只能同源使用的限制，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 请求。 CORS 一般用XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS，目前IE浏览器的老版本还不支持。 CORS 需要浏览器和服务器同时支持才可以生效，对于开发者来说，CORS 通信与同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 具体的方法是在服务端设置Response Header响应头中的Access-Control-Allow-Origin为对应的域名，实现了CORS（跨域资源共享），这里出于在安全性方面的考虑就是尽量不要用 *，但对于一些不重要的数据则随意，例如图片 Node.js实现CORS的方法 1234567891011121314app.post('/cors', function(req, res) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); //设置请求来源不受限制 res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\"); //请求方式 res.header(\"X-Powered-By\", ' 3.2.1') res.header(\"Content-Type\", \"application/json;charset=utf-8\"); var data = &#123; name: req.body.name + ' - server 3001 cors process', id: req.body.id + ' - server 3001 cors process' &#125; console.log(data) res.send(data) res.end()&#125;) 服务端代理 server proxy（跨全域）服务器代理，顾名思义，当你需要有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后最后将获取的结果发送给你。在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限，我们可以通过server proxy的方式来抓取数据。 例如当baidu.com域下的页面需要请求google.com下的资源文件getUsers.php时，直接发送一个指向google.com/getUsers.php的Ajax请求肯定是会被浏览器阻止。这时，我们在Baidu.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如baidu.com/proxy/,然后这个代理发送HTTP请求访问google.com下的getUsers.php，跨域的HTTP请求是在服务器端进行的（服务器端没有同源策略的限制），客户端并没有产生跨域的Ajax请求。 情景：你的页面需要获取Nodejs专业中文社区 论坛上一些数据，如通过https://cnodejs.org/api/v1/topics，当时因为不同域，所以你可以将请求后端，让其对该请求代为转发。 代码如下： 12345678910111213141516171819202122const url = require('url');const http = require('http');const https = require('https');const server = http.createServer((req, res) =&gt; &#123; const path = url.parse(req.url).path.slice(1); if(path === 'topics') &#123; https.get('https://cnodejs.org/api/v1/topics', (resp) =&gt; &#123; let data = \"\"; resp.on('data', chunk =&gt; &#123; data += chunk; &#125;); resp.on('end', () =&gt; &#123; res.writeHead(200, &#123; 'Content-Type': 'application/json; charset=utf-8' &#125;); res.end(data); &#125;); &#125;) &#125;&#125;).listen(3000, '127.0.0.1');console.log('启动服务，监听 127.0.0.1:3000'); 通过代码你可以看出，当你访问http://127.0.0.1:3000的时候，服务器收到请求，会代你发送请求https://cnodejs.org/api/v1/topics最后将获取到的数据发送给浏览器。 这个跨域方式下不需要和目标资源签订协议，带有侵略性。 window namewindow 对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。那么我们可以在页面 A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后（iframe.onload），页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出iframe的window.name的值了（因为A中的window.name和iframe中的window.name互相独立的，所以不能直接在A中获取window.name，而要通过iframe获取其window.name）。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。 flash URLLoaderflash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。当跨域访问资源时，例如从域baidu.com请求域google.com上的数据，我们可以借助flash来发送HTTP请求。首先，修改域google.com上的crossdomain.xml(一般存放在根目录，如果没有需要手动创建) ，把baidu.com加入到白名单。其次，通过Flash URLLoader发送HTTP请求，最后，通过Flash API把响应结果传递给JavaScript。Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持iOS的话，这个方案就不可行了。 Access Control 此跨域方法目前只在很少的浏览器中得以支持，这些浏览器可以发送一个跨域的HTTP请求（Firefox, Google Chrome等通过XMLHTTPRequest实现，IE8下通过XDomainRequest实现），请求的响应必须包含一个Access-Control-Allow-Origin的HTTP响应头，该响应头声明了请求域的可访问权限。例如baidu.com对google.com下的getUsers.php发送了一个跨域的HTTP请求（通过ajax），那么getUsers.php必须加入如下的响应头： 1header(&quot;Access-Control-Allow-Origin: http://www.baidu.com&quot;);//表示允许baidu.com跨域请求本文件` document domain对于两个iframe之间 主域相同而子域不同的情况下，可以通过设置document.domain的办法来解决，具体做法是可以在http://www.example.com/a.html和http://sub.example.com/b.html两个文件分别加上 document.domain = &quot;a.com&quot;；然后通过a.html文件创建一个 iframe，去控制 iframe 的 window，从而进行交互，当然这种方法只能解决主域相同而二级域名不同的情况，如果你异想天开的把 script.example.com的 domain 设为qq.com显然是没用的. 通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如baidu.com和youxi.baidu.com是不同的域，这时，我们无法在baidu.com下的页面中调用youxi.baidu.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为baidu.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相获取对方数据或者操作对方DOM了。 问题： 1、安全性，当一个站点被攻击后，另一个站点会引起安全漏洞。 2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。 location hash适用于两个iframe之间，又称FIM，Fragment Identitier Messaging的简写因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。下面举例说明： 假如父页面是baidu.com/a.html，iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。 123456789101112131、a.html传送数据到b.html（1） a.html下修改iframe的src为google.com/b.html#paco（2） b.html监听到url发生变化，触发相应操作2、b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe（1） b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=&quot;http://www.baidu.com/proxy.html#data&quot;（2） proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）（3） a.html监听到url发生变化，触发相应操作 b.html页面的关键代码如下 123456789try &#123; parent.location.hash = &apos;data&apos;; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， var ifrproxy = document.createElement(&apos;iframe&apos;); ifrproxy.style.display = &apos;none&apos;; ifrproxy.src = &quot;http://www.baidu.com/proxy.html#data&quot;; document.body.appendChild(ifrproxy); &#125; 因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 使用HTML5的postMessage方法不能和服务端交换数据,只能两个iframe之间或者两个页面之间postMessage 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 都支持这项功能，使用起来也特别简单。 安全性： postMessage 采用的是 双向安全机制 。发送方发送数据时，会确认接收方的源，而监听方监听到 message 事件后，也可以用event.origin判断是否来自于正确可靠的发送方 参考：PostMessage_百度百科Window.postMessage() 这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。比如baidu.com域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信 A页面通过postMessage方法发送消息： 12345window.onload = function() &#123; var ifr = document.getElementById(&apos;ifr&apos;); var targetOrigin = &quot;http://www.google.com&quot;; ifr.contentWindow.postMessage(&apos;hello world!&apos;, targetOrigin); &#125;; postMessage的使用方法： otherWindow.postMessage(message, targetOrigin); otherWindow: 指目标窗口，也就是给哪个window发消息，是 window.frames属性的成员或者由window.open方法创建的窗口 message: 是要发送的消息，类型为 String、Object (IE8、9 不支持) targetOrigin: 是限定消息接收范围，不限制请使用 * B页面通过message事件监听并接受消息: 12345678910111213141516var onmessage = function (event) &#123; var data = event.data;//消息 var origin = event.origin;//消息来源地址 var source = event.source;//源Window对象 if(origin==&quot;http://www.baidu.com&quot;)&#123; console.log(data);//hello world! &#125; &#125;; if (typeof window.addEventListener != &apos;undefined&apos;) &#123; window.addEventListener(&apos;message&apos;, onmessage, false); &#125; else if (typeof window.attachEvent != &apos;undefined&apos;) &#123; //ie兼容 window.attachEvent(&apos;onmessage&apos;, onmessage); &#125; 同理，也可以B页面发送消息，然后A页面监听并接受消息。 webSocketwebsocket是一中全双工通信协议，该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信websocket的应用实例 总结及参考资料跨域的方法很多，不同的应用场景我们都可以找到一个最合适的解决方案。比如单向的数据请求，我们应该优先选择JSONP或者window.name，双向通信优先采取location.hash，在未与数据提供方达成通信协议的情况下我们也可以用server proxy的方式来抓取数据。(其实讲道理，常用的也就是前三种方式) 关于跨域，你想知道的全在这里深入理解前端跨域问题的解决方案——前端面试几种跨域方式总结你了解跨域请求吗？","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"js","slug":"js","permalink":"http://ldc5886.github.io/tags/js/"}],"author":"D橙"},{"title":"常用PS切图方式","slug":"常用PS切图方式","date":"2019-05-31T16:00:00.000Z","updated":"2019-10-13T14:32:36.081Z","comments":true,"path":"2019/06/01/常用PS切图方式/","link":"","permalink":"http://ldc5886.github.io/2019/06/01/%E5%B8%B8%E7%94%A8PS%E5%88%87%E5%9B%BE%E6%96%B9%E5%BC%8F/","excerpt":"","text":"###切片工具切图（切多张）选中切片工具 ——&gt; 按住鼠标左键拖拽选中要切的部分 ——&gt; 选择菜单栏“文件” ——&gt; “导出” ——&gt; “存储为web所用格式” ——&gt; 点击选中要截的图片，并设置格式 ——&gt;点击“存储”，“切片”选项选择“所有用户切片” ——&gt; 点击“保存” 图文教程可以参考前端开发人员也要会的切图技巧(一)前端开发人员也要会的切图技巧(二) ###裁切切图（切单张）按图层实际大小来保存，主要在有阴影效果的图层使用 选中该图片所在的图层或组 ——&gt; 单击鼠标右键选“复制组”或“复制图层”（“目标”“文档” 选择 “新建”） ——&gt; 选择菜单栏“图像” ——&gt; 选择“裁切”（“基于”选“透明像素”） ——&gt;选择菜单栏“文件” ——&gt; “存储为” ###自动化切图（仅支持PS CC及以上版本）先提前设置 选择菜单栏“编辑” ——&gt; “首选项” ——&gt; “常规” ——&gt; “增效工具” ——&gt; 勾选“启用生成器” ——&gt; 选择“确定” ——&gt;选择菜单栏“文件” ——&gt; “生成” ——&gt; 勾选“图像资源” 切图方式为选中该图片所在的图层或组 ——&gt; “ctrl+J”复制 ——&gt; 重命名为“新名称.格式”如icon.jpg ——&gt; 回车确定即可 图文教程可以参考前端开发人员也要会的切图技巧(三) png8和png-24的区别： 1、png8是一个256色的图片，png24则是一个1670万色的图片 2、png8的压缩率比png24高很多，所以png8图片的大小会比png24小很多。 3、png8的全透明没有png24的质量高。 4、png8在半透明和透明的情况下会有毛边锯齿的现象，png24则不会 ###其他进阶资料写给前端小白的切图技巧（实用）前端实战系列之—两种快速切图的方法","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"ps","slug":"ps","permalink":"http://ldc5886.github.io/tags/ps/"}],"author":"D橙"},{"title":"JS 闭包","slug":"JS 闭包","date":"2019-05-28T16:00:00.000Z","updated":"2019-10-13T14:38:09.913Z","comments":true,"path":"2019/05/29/JS 闭包/","link":"","permalink":"http://ldc5886.github.io/2019/05/29/JS%20%E9%97%AD%E5%8C%85/","excerpt":"","text":"什么是闭包？它的优点与缺点是？闭包：闭包是就是函数中的函数，里面的函数可以访问外面函数的变量，外面的变量的是这个内部函数的一部分。（应用场景：要获取某函数内部的局部变量或是需要让局部变量发挥全局变量的作用时，可以考虑使用闭包） 创建：最常见的方法就是函数里面定义另外一个函数，然后在这个内部函数中使用外部函数的参数或者变量，再通过外部的其他函数或事件等持续的引用或触发这个内部函数。（一定要是持续的！！！！） 特点：1 函数嵌套函数2 内部函数可以引用外部的参数和变量3 被引用的参数或者变量不会被垃圾回收机制回收 闭包的优点： 1.使用闭包可以能够在外部读取其他函数内部的变量。 2.可以使变量长期保存在内存中，生命周期比较长。让局部变量发挥全局变量的作用，预防全局变量可能会造成命名冲突问题，保护变量的安全 闭包的缺点：由于闭包会使函数中的变量保存在内存中，会增加内存的消耗，而且滥用闭包，可能会导致内存泄露，影响网页的性能。解决办法是，闭包使用完了后，要立即释放资源，将引用变量指向null。 ** 使用闭包并不会引起内存泄漏！！ 只是由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集，从而导致内存无法进行回收，这是IE的问题，所以闭包和内存泄漏没半毛钱关系。闭包泛滥使用才容易导致内存泄露，这是程序员的问题不是闭包的问题，** 闭包1. 变量作用域与垃圾回收机制要理解闭包，首先要理解javascript的特殊的变量作用域。 变量的作用域无非就两种：全局变量和局部变量。 js语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。 在函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明的是一个全局变量！ js不需要手动回收变量，js 中的 变量 函数 不再使用后，会被自动js垃圾回收机制回收 只有局部变量会被回收，全局变量不会被回收（除非关闭当前网页），所以当我们定义了一个引用型全局变量，不再使用时，请手动讲值置为null，已释放内存。 2. 闭包的定义出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。 那就是在函数内部，再定义一个函数。 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。 这就是js语言特有的”链式作用域”结构（chain scope）， 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 上面代码中的f2函数，就是闭包。 闭包就是能够读取其他函数内部变量的函数，也可以说是一个可以访问另一个函数作用域里面变量的函数。 函数没有被释放，整条作用域链上的局部变量都将得到保留。 由于在js中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成‘定义在一个函数内部的函数’。 所以，在本质上，闭包就是将函数内部和函数外部连接的一座桥梁。 3. 闭包的特点及形成闭包条件闭包的特点：1 函数嵌套函数2 内部函数可以引用外部的参数和变量3 被引用的参数或者变量不会被垃圾回收机制回收 形成闭包条件： 条件一： 函数内部嵌套函数 条件二： 内部函数引用外部函数的 变量 参数，使用 return 返回了 此内部函数,上面的 变量 和参数 就不会被回收 通常建立闭包的方法：1.函数里面定义另外一个函数2.内部函数使用了外部函数的参数或者变量3.内部函数能被外部或事件等持续的引用或触发。（一定要是持续的！！！！） 4. 闭包作用如下： 避免使用全局变量，实现数据隐藏和保持，也就是面向对象的特性：封装。 当成员变量比较少，以及方法只有一个时，比类更简单实现。 数据和函数一起封装，适应异步或并发运行。 5. 闭包的使用闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在调用后被自动清除，例如上文的f1，为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。。 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 *返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变* 使用闭包能够让局部变量模拟全局变量一样，但是它只能被特定函数使用。我们都知道： 1.全局变量可能会造成命名冲突，使用闭包不用担心这个问题，因为它是私有化，加强了封装性，这样保护变量的安全 2.每个模块都可以调用，当程序越来越复杂之后，会带不可预测的危险 所以推荐变量尽量私有化，当我们需要让局部变量发挥全局变量的作用时，可以考虑使用闭包 闭包的运用非常的多，不是一个例子两个例子能讲得完的，后期写代码的过程中要灵活运用。 123456789//伪代码 -- 就是说假设这里使用的变量已经定义过了//序列号for(var i=0;i&lt;length;i++)&#123; (function(i)&#123; aP[i].onclick = function()&#123; alert(i); &#125; &#125;)(i);&#125; 12345678//不需要全局变量的点击事件计数document.onclick = (function()&#123; var num = 0; return function()&#123; num ++; alert(num); &#125;;&#125;)(); 123456789101112function fn(x)&#123; var a = 5; function innerFn()&#123; console.log(x); console.log(a); &#125; return innerFn;&#125;var c = fn(20);c();// 20 //5 进阶理解破解前端面试：从 闭包说起 大部分人都会做错的经典JS闭包面试题 MDN闭包 为什么要使用闭包（closures）","categories":[{"name":"note","slug":"note","permalink":"http://ldc5886.github.io/categories/note/"}],"tags":[{"name":"js","slug":"js","permalink":"http://ldc5886.github.io/tags/js/"}],"author":"D橙"},{"title":"JS 原型链详解","slug":"JS 原型链详解","date":"2019-05-28T16:00:00.000Z","updated":"2019-10-13T14:35:59.890Z","comments":true,"path":"2019/05/29/JS 原型链详解/","link":"","permalink":"http://ldc5886.github.io/2019/05/29/JS%20%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"关于JS原型链的理解原型:每一个对象（除null外）都有另一个对象与之相关联，这个另一个对象便称之为“原型”(prototype),每个对象都是从原型继承属性。 原型链:一系列链接的原型对象的链称为“原型链”(prototype chain)。对象通过原型链的方式实现了相关联（即我们常称作原型链的方式实现了继承） 对象实例化方式原始模式123456var Car = &#123; color: 'red', //车的颜色 wheel: 4, //车轮数量&#125;alert(Car.color);//red 生成两个实例对象 123456789101112131415161718192021222324252627var Car = &#123; color: 'red', wheel: 4,&#125;var Car2 = &#123; color: 'blue', wheel: 4,&#125;```js这样的写法有两个缺点，一是如果多生成几个（100个！）实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。#### 原始模式的改进我们可以写一个函数，解决代码重复的问题。```jsfunction createCar(color,wheel) &#123; return &#123; color:color, wheel:wheel &#125; &#125;//然后生成实例对象，就等于是在调用函数：var cat1 = createCar(\"红色\",\"4\");var cat2 = createCar(\"蓝色\",\"4\");alert(cat1.color); //红色 工厂模式1234567891011function createCar(color,wheel)&#123; //createCar工厂 var obj = new Object; //或obj = &#123;&#125; 原材料阶段 obj.color = color; //加工 obj.wheel = wheel; //加工 return obj; //输出产品&#125;//实例化var cat1 = createCar(&quot;红色&quot;,&quot;4&quot;);var cat2 = createCar(&quot;蓝色&quot;,&quot;4&quot;);alert(cat1.color);//红色 构造函数模式为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。 12345678910111213function CreateCar(color,wheel)&#123;//构造函数首字母大写 //不需要自己创建对象了 this.color = color;//添加属性，this指向构造函数的实例对象(cat1、cat2) this.wheel = wheel;//添加属性 //不需要自己return了&#125;//实例化var cat1 = new CreateCar(&quot;红色&quot;,&quot;4&quot;);var cat2 = new CreateCar(&quot;蓝色&quot;,&quot;4&quot;);alert(cat1.color); //红色 首先定义一个构造函数CreateCar，然后对这个构造函数实例化了两个对象cat1和cat2。( CreateCar称为cat1和cat2的原型对象（简称原型）， cat1，cat2称为CreateCar的实例对象)实例可以访问原型对象上定义的属性和方法 *new 函数构造内部变化： 自动生成一个对象this指向这个对象函数自动返回这个对象* 构造函数注意事项 此时CreateCar称之为构造函数，也可以称之类，构造函数就是类 CreateCar 构造函数中this指向CreateCar实例对象即 new CreateCar( )出来的对象cat1和cat2 必须带new 构造函数首字母大写，这是规范，官方都遵循这一个规范，如Number() Array() 理解 constructor，protototype，proto 属性每个构造函数都有一个prototype属性，这个属性是一个指针,指向一个prototype对象，而这个prototype对象中保存着构造函数的原型属性和一个constructor属性，该constructor属性,这个属性也是一个指针,指向了构造函数CreateCar本身. 实例是通过构造函数创建的。无prototype属性，但实例一创造出来就具有constructor属性（指向构造函数）和proto属性（指向该实例的原型对象） cat1和cat2会自动含有一个constructor属性，指向它们的构造函数,即CreateCar。 12345678910111213141516function CreateCar(color,wheel)&#123; //构造函数首字母大写 //不需要自己创建对象了 this.color = color; //添加属性，this指向构造函数的实例对象(cat1、cat2) this.wheel = wheel; //添加属性 //不需要自己return了&#125;//实例化var cat1 = new CreateCar(&quot;红色&quot;,&quot;4&quot;);var cat2 = new CreateCar(&quot;蓝色&quot;,&quot;4&quot;);alert(cat1.color); //红色alert(cat1.constructor == CreateCar); //truealert(cat2.constructor == CreateCar); //true 以CreateCar和cat1为例，其属性结构关系如下图所示 原型链什么是原型链简单来说就是函数原型通过继承关系联系在一起，形成的链式结构就被叫做原型链。简单来说就是在实现原型继承的时候，会将下级函数的原型和上级函数的实例联系起来，那么多个构造函数相互继承，将彼此的原型联系起来就形成了原型链。 实际上所有函数都有自己的原型对象；因为函数在广义上可以认为是对象 对象能作为其他对象的原型对象，也能作为原型对象的实例化对象，由此形成了prototype chain原型链 所有的对象的原型对象如果一层层往上“回溯”，最后可以回溯到Object.prototype;而Object.prototype的原型对象是null,null没有自己的原型对象!!! 在面向对象原型链中常见的函数1.hasOwnProperty()判断一个属性是否是自有属性，还是继承原型属性。必须用字符串指定该属性。如果是的话返回true，否则的返回false 12345671. function fn(index)&#123;2. this.index = index;3. &#125;4. fn.prototype.name = &apos;二狗&apos;;5. var obj = new fn(88);6. console.log( obj.hasOwnProperty(&apos;index&apos;) );//true7. console.log( obj.hasOwnProperty(&apos;name&apos;) );//false 2.isPrototypeOf()判断该对象的原型是否为xxxxx。 返回true 或 falseObj.constructor.prototype.isPrototypeOf(Obj) //true 原型链中对象属性的查找规则读取对象的某个属性时，js引擎会先在对象本身属性上寻找，如果找不到，那么去其原型对象的prototype上找(不会查找其原型对象的内部属性！！)，如果没有的话就会沿着原型链向上查找，一层一层往上”回溯”,直至null.找到的话就返回属性值，如果都没有的话就会返回undefined。所以如果找寻某个不存在的属性，会将完整的原型链遍历一变，对性能影响较大。 举个例子 123456789101112131415161718192021222324 //原型链中属性的查找 function Person(name,color)&#123; this.name=name; this.color=color; &#125; function Teacher(name,age)&#123;Teacher.color = &quot;红色&quot;; this.name=name; this.age=age; &#125; //实现继承 Teacher.prototype=new Person(); Teacher.prototype.book=&quot;书本&quot;; var t1=new Teacher(&quot;aa&quot;,32); //查找属性 //1.当Teacher中含有name属性，不管有没有赋值都表明在Teacher中含有name属性 console.log(t1.name); //aa //2.当查找Teacher中没有的属性的时候,但是Teacher的原型中有该属性 console.log(t1.book); //书本 //3.当查找Teacher原型和本身都没有属性的时候，但是上级函数中有该属性的时候 console.log(t1.color); //undefined 以上的三种情况就是一个很明显的利用原型链查找属性的例子，可以写个demo简单实验一下，只要测试过之后肯定能够很清晰的理解啦。 原型继承利用call()及for in 继承,如 123456789101.function inherit()&#123;2.3. fn.call(obj3,&apos;旺财&apos;);4. for(key in fn.prototype)&#123;5. if(!obj3[key])&#123;6. obj3[key] = fn.prototype[key];7. &#125;8.9. &#125;10. &#125; 12345678910111.function inherit(constructor,obj,ownAttr)&#123;2. constructor.call(obj3,ownAttr);3. for(key in constructor.prototype)&#123;4. if(!obj[key])&#123;5. obj[key] =constructor.prototype[key];6. &#125;7.8. &#125;9.10.11.&#125; 构造函数实例方式继承 1.利用obj.constructor.prototype 继承对象 自身属性及 继承属性 1234567891011121. function fn(name)&#123;2. this.name = name;3. &#125;4. fn.prototype.index = &apos;88&apos;;5. function fn2(age)&#123;6. this.age = age;7. &#125;8. fn2.prototype = new fn(&apos;旺财&apos;);9. var obj = new fn2(66);10. console.log(obj.name);//旺财11. console.log(obj.index);//8812. console.log(obj.age);//88 2.利用 prototype 继承对象 自身属性及 继承属性 123456789101112131. function fn(name)&#123;2. this.name = name;3. &#125;4. fn.prototype.index = &apos;88&apos;;5. 5. function fn2(age)&#123;6. this.age = age;7. &#125;8. 8. var obj = new fn(&apos;二狗&apos;);9. fn.prototype = Object.create(fn.prototype);10. console.log(obj.name);//二狗11. console.log(obj.index);//88 在上面例子中 可以发现,给对象的constructor.prototype添加方法属性 对象就会继承 obj.constructor.prototype 与 对象obj.proto 的关系 ,带__为非标准属性 123451.function fn(name)&#123;2. this.name = name;3. &#125;4.var obj = new fn(&apos;二狗&apos;);5. console.log( obj.__proto__ === fn.prototype ) //true， 3.一个对象继承其他对象 对象继承对象 12341.var obj = &#123;name : &apos;hello&apos;&#125;2.var obj2 = &#123;age:30&#125;3.obj2.__proto__ = obj;4.console.log( obj2.name);//hello 继承构造函数实例对象 1234567891.function fn(name)&#123;2. this.name = name;3. &#125;4. var obj = new fn(&apos;hello&apos;);5. var obj2 = &#123;6. age:30,7. __proto__:obj8. &#125;9. console.log(obj2.name);//hello; 进阶理解MDN原型链","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"js","slug":"js","permalink":"http://ldc5886.github.io/tags/js/"}],"author":"D橙"},{"title":"使用Babel","slug":"使用Babel","date":"2019-05-25T16:00:00.000Z","updated":"2019-10-13T14:45:42.345Z","comments":true,"path":"2019/05/26/使用Babel/","link":"","permalink":"http://ldc5886.github.io/2019/05/26/%E4%BD%BF%E7%94%A8Babel/","excerpt":"","text":"Babel使用规则Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。 这意味着，你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持。下面是一个例子。 12345678// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;);//上面的原始代码用了箭头函数，这个特性还没有得到广泛支持，Babel将其转为普通函数，就能在现有的JavaScript环境执行了。 1.安装babelBabel提供babel-cli工具，用于命令行转码。 它的安装命令如下： 12//需要先安装node环境npm install --global babel-cli 2.配置文件.babelrcBabel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下。 1234&#123; \"presets\": [], \"plugins\": []&#125; presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 12345678# ES2015转码规则npm install --save-dev babel-preset-es2015# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个npm install --save-dev babel-preset-stage-0npm install --save-dev babel-preset-stage-1npm install --save-dev babel-preset-stage-2npm install --save-dev babel-preset-stage-3 然后，将这些规则加入.babelrc。 12345678//例如：按需求添加&#123; \"presets\": [ \"es2015\", \"stage-2\" ], \"plugins\": []&#125; 3.用法1234567891011121314151617# 转码结果输出到标准输出$ babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ babel example.js --out-file compiled.js# 或者$ babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ babel src --out-dir lib# 或者$ babel src -d lib# -s 参数生成source map文件$ babel src -d lib -s 上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel，也就是说项目产生了对环境的依赖。另一方面，这样做也无法支持不同项目使用不同版本的Babel。 一个解决办法是将babel-cli安装在项目之中。 12# 安装npm install --save-dev babel-cli 然后，改写package.json。 123456789&#123; // ... \"devDependencies\": &#123; \"babel-cli\": \"^6.0.0\" &#125;, \"scripts\": &#123; \"build\": \"babel src -d lib\" &#125;,&#125; 转码的时候，就执行下面的命令。 1npm run build","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"js","slug":"js","permalink":"http://ldc5886.github.io/tags/js/"},{"name":"babel","slug":"babel","permalink":"http://ldc5886.github.io/tags/babel/"}],"author":"D橙"},{"title":"Canvas中save与restore作用详解","slug":"Canvas中save与restore作用详解","date":"2019-05-25T16:00:00.000Z","updated":"2019-10-13T14:37:34.985Z","comments":true,"path":"2019/05/26/Canvas中save与restore作用详解/","link":"","permalink":"http://ldc5886.github.io/2019/05/26/Canvas%E4%B8%ADsave%E4%B8%8Erestore%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"save与restoresave()主要用来保存目前Canvas的状态，例如lineWidth、fillStyle、lineJoin等，通过save()函数它会将目前Canvas的状态推到绘图堆栈中；而restore()函数就是从绘图堆栈中弹出上一个Canvas的状态。 通过save-restore组合把代码包裹起来，实质上是把save()方法和restore()方法之间的样式包裹起来，这样一来，他们就不影响后面绘制的图形。save()方法和restore()方法都可以被调用任意多次，并且可以嵌套。save()方法和restore()方法总是成对出现，每次调用restore()方法，都是恢复到最近一次调用save()方法时栈的状态，并用该栈顶所保存的状态进行绘制。 save与restore的使用下面是一个例子首先，现在body标签中创建一张画布&lt;canvas width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;然后执行下方的代码 12345678910111213141516171819202122const cv = document.querySelector(\"canvas\");const c = cv.getContext(\"2d\");c.fillStyle = \"red\";c.fillRect(10, 10, 180, 180);c.fill();c.save(); // ① 栈: \"red\"c.fillStyle = \"green\";c.fillRect(30, 30,140,140);c.save(); // ② 栈: \"red\"，\"green\"c.fillStyle = \"blue\";c.fillRect(50, 50, 100,100);c.restore(); // 恢复到 ② 的状态, 栈: \"red\"，\"green\"c.beginPath();c.fillRect(70, 70, 60, 60); // 用栈顶的状态绘图，填充\"green\"c.restore(); // 恢复到 ① 的状态, 栈: \"red\"c.fillRect(90, 90, 20, 20); // 用栈顶的状态绘图，填充\" red \"c.fill(); 运行结果如图 上述代码中，首先绘制第一个红色的矩形。接着调用第一个save()方法，把第一个红色矩形的状态压栈，此时栈中只有一个元素”red”，记为 ①。然后把状态设置为”green”，绘制第二个矩形，此时绘制出的是绿色矩形。接着调用第二个save()方法，把第二个绿色矩形的状态压栈，此时栈中有两个元素”red”，”green”，栈顶元素为”green”，记为 ②。接着绘制第三个蓝色矩形，此处没有调用save()方法，栈的状态不变。接着调用restore()方法，恢复到 ② 的状态，绘制第四个矩形，此时栈顶元素为”green”，故绘制出绿色矩形。接着再调用restore()方法，恢复到 ① 的状态，绘制第五个矩形，此时栈顶元素为”red”，故绘制出红色矩形。 save与restore的继承问题代码从上往下覆盖执行，因此所有未加beginpath进行隔断的图形样式都会继承上最新设置定义的样式，类似污染对于下方的代码可自行调试，实验 123456789101112131415161718192021222324252627282930313233c.moveTo(50,100);c.lineTo(50,200);c.stroke();c.lineWidth = 10;c.strokeStyle = 'red';c.moveTo(100,100);c.lineTo(100,200);c.stroke();c.save();//保存 将上方设置的样式在释放的下方进行应用 c.beginPath();//进行重置隔断，可理解为划分作用域，不会相互污染 c.strokeStyle = 'green'; c.lineWidth = 20;c.moveTo(150,100);c.lineTo(150,200);c.stroke();c.restore();//释放 在beginpath的上下方都不影响 c.beginPath();//进行重置隔断//c.lineWidth = 30;//c.strokeStyle = 'pink';c.moveTo(200,100);c.lineTo(200,200);c.stroke();c.moveTo(250,100);c.lineTo(250,200);c.stroke();","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"css","slug":"css","permalink":"http://ldc5886.github.io/tags/css/"},{"name":"canvas","slug":"canvas","permalink":"http://ldc5886.github.io/tags/canvas/"}],"author":"D橙"},{"title":"CSS兼容性问题","slug":"CSS兼容性问题","date":"2019-05-25T16:00:00.000Z","updated":"2019-10-13T14:35:24.057Z","comments":true,"path":"2019/05/26/CSS兼容性问题/","link":"","permalink":"http://ldc5886.github.io/2019/05/26/CSS%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/","excerpt":"","text":"兼容性问题1. 每个属性必须兼容吗css3属性（例如transition，border-radius），超大一部分肯定是不兼容IE8，部分不兼容IE9/IE10，部分根本不兼容IE。可以使用超复杂的js来解决部分的问题，但是并不完美，也使代码增加不必要的复杂度，所以不需要也不推荐去处理css3属在IE里面的兼容显示，但是一定要保证正常布局和浏览。 IE8-（主要指IE6，IE7）浏览器的兼容，某些属性和现代浏览器以及IE高版本显示差异巨大（例如fixed定位的不支持、min-width等的不支持，定位auto居中方式不支持），且目前IE浏览器的市场占比份额已经低的可怜，请放弃繁琐的IE8-浏览器的兼容，抵制辣鸡浏览器从我做起。非得兼容可以参考后面部分的IE-hack。 2. 常见的兼容处理opacity，IE8及以下不支持，使用滤镜filter:alpha(opacity=值)来代替； rgba颜色、HSL颜色，IE8级以下不支持，在rgba之前始终定义一种通用颜色保证IE的代替方案； 部分选择器，IE6不支持属性选择器、子元素选择器 &gt;、相邻兄弟选择器 +，没有替代的方案，考虑实际情况做取舍； :hover等伪类，IE6只支持a标签的hover，考虑实际情况做取舍； 查看兼容性的非常好用的网站： Can I Use 3. 超好用的IE条件语句这个东西就很牛逼了，这种判断写法只有IE能认识，其他浏览器会当做正常注释来处理，一起来看一下： 1234567891011121314151617181920212223&lt;!--[if IE]&gt; 只有IE才支持&lt;![endif]--&gt;&lt;!--[if !IE 7]&gt; IE7不支持&lt;![endif]--&gt;&lt;!--[if lt IE 8]&gt; IE8以下浏览器才支持&lt;![endif]--&gt;&lt;!--[if lte IE 8]&gt; IE8及以下浏览器才支持&lt;![endif]--&gt;&lt;!--[if gt IE 8]&gt; IE8以上浏览器才支持&lt;![endif]--&gt;&lt;!--[if gte IE 8]&gt; IE8及以上浏览器才支持&lt;![endif]--&gt; 4. 优雅降级与渐进增强通俗一点来解释吧： 优雅降级：开始项目 -&gt; 管TM的兼容性先干了再说 -&gt; 网站写完了现代浏览器显示屌的不行 -&gt; 低版本浏览器有问题 -&gt; 改一改吧，保证正常的显示。 渐进增强：开始项目 -&gt; 猥琐点先用全浏览器兼容的主体布局 -&gt; 这个模块我可以使用新的CSS3让他在现代浏览器表现的更好！ -&gt; 还有这里也可以表现的更好 -&gt; 行了，低版本浏览器显示不会乱，但是优秀的浏览器有更优秀的显示。 采用哪种呢？没有定论，依据项目的实际情况来定吧，比如项目不再在于IE低版本，当然采用优雅降级方式，写完了调整一下IE9+的显示就ok。比如项目很需要保证稳定性和各平台的正确显示性，采用渐进增强。 5. 很JR蛋疼的css hack需要做IE6 IE7兼容的前端者，这可能对你有用。 有些比较骚的css写法只能特定的IE浏览器才能解析： 只有IE6能解析： p { _color:red; } *****p {color:red;} 只有IE7能解析： *+p {color:red;} IE6与IE7能解析： p {***color:red;} p {#color:red;} p {+**color:red;} IE6 IE7与IE8： p {color:red\\9;} IE8以上能解析： p {color:red\\0;} 还有一些，甚至有专业的前辈列出了表，有兴趣的兄dei百度了解更多吧","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"css","slug":"css","permalink":"http://ldc5886.github.io/tags/css/"},{"name":"compatible","slug":"compatible","permalink":"http://ldc5886.github.io/tags/compatible/"}],"author":"D橙"},{"title":"了解webpack","slug":"了解webpack","date":"2019-05-25T16:00:00.000Z","updated":"2019-10-13T14:39:22.537Z","comments":true,"path":"2019/05/26/了解webpack/","link":"","permalink":"http://ldc5886.github.io/2019/05/26/%E4%BA%86%E8%A7%A3webpack/","excerpt":"","text":"安装webpack webpack是一个前端打包工具 1234#要使用npm，必须先安装nodejs//node安装完成后，打开终端，在全局安装webpack，方法如下：npm install -g webpack//等待安装完成...... 创建配置项 使用webpack，必须设置好配置项 每个项目的依赖不一样，配置项也会不一样，所以配置项需要在项目的根目录配置: 首先，在项目根目录 按 shift+右键 –&gt; 在此处打开命令窗口 然后输入：npm init 然后连按7-8次回车，直到根目录出现 package.json 文件 配置package.json 配置package是使用webpack非常重要的一步 安装webpack依赖，在终端输入：npm install --save-dev webpack，等待成功。 使用webpack 使用webpack进行打包，为了可以一次打包多个文件，此时还需要配置一个文件webpack.config.js 在根目录新建一个webpack.config.js文件 1234567891011//webpack.config.jsmodule.exports = &#123; //__dirname是nodejs里的一个全局变量，它指向的是项目的根目录 entry:__dirname + \"/app/main.js\", //入口文件路径，例如入口文件是：根目录下的app文件夹里的main.js output:&#123; //设置出口文件（打包后的文件）位置 path:__dirname+\"/public/\", //出口文件名 filename:\"index.js\" &#125;&#125; webpack.config.js配置完成后，使用webpack打包，直接在cmd输入webpack回车即可。 输出的文件在根目录的public/index.js，然后引入index.js到你的html文件，开始疯狂输出把。 每次使用cmd，除了可以webpack回车打包以外， 还可以在package.json里的scripts下，添加一个属性start值为webpack 这样以后使用就可以在cmd里输入：npm start，跟前面输入webpack一样的效果 ps:start是一个关键字，如果需要自定义如：fy 那么使用的就不能npm fy，而是需要npm run fy Loaders Loaders是webpack中最核心的功能，通过使用不同的loader，webpack通过调用外部的脚本或工具，可以对各种文件进行处理，比如说：分析json文件并把它转为JavaScript文件，或者把es6的代码转为es5，还可以把react的JSX转为js文件等等 Loaders需要单独安装并在webpack.config.js下的module下进行配置，配置包括以下几方面： test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） use：一个数组，里面是对象，对象里是loader：css-loader这种类型 例如： 使用json的loader1npm install --save-dev json-loader json-loader不需要需要配置文件 处理样式表webpack提供两个工具处理样式表，css-loader和style-loader： css-loader使你能够使用类似@import和url(…)的方式实现require()的功能 style-loader将所有的样式计算后，加入页面。两者组合在一起使你能够把样式表嵌入webpack打包的文件里 安装命令： 1npm install --save-dev style-loader css-loader 配置项： 1234567891011module:&#123; rules:[ &#123; test:/\\.css$/, use:[ &#123;loader:\"style-loader\"&#125;, &#123;loader:\"css-loader\"&#125; ] &#125; ]&#125; 打包时编译打包的时，如果需要编译es6代码为旧版浏览器支持的es5代码，需要使用一些相关的loader 123456npm install babel-core --savenpm install babel-loader --savenpm install babel-preset-es2015 --save//需要安装三个需要的插件，可以一次性安装#npm install babel-core babel-loader babel-preset-es2015 --save//(不要输入#) 安装完成后需要配置相关文件。 12345//首先需要配置babel编译需要的配置文件： .babelrc&#123; \"presets\": [\"es2015\"], \"plugins\": []&#125; 然后需要设置webpack的配置文件 1234567891011121314151617//webpack.config.jsmodule.exports = &#123; //入口文件 entry: __dirname + \"/js/main.js\", output: &#123; //webpack打包后的输出的路径 path: __dirname, //输出的文件名 filename: 'index.js' &#125;, module: &#123; rules: [ // exclude 排除，不需要编译的目录，提高编译速度 (node_modules是模块安装的位置，不需要编译) &#123;test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/&#125; ] &#125;&#125;","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://ldc5886.github.io/tags/webpack/"}],"author":"D橙"},{"title":"CSS 书写顺序与常用命名参考","slug":"CSS 书写顺序与常用命名参考","date":"2019-05-24T16:00:00.000Z","updated":"2019-10-13T14:45:06.673Z","comments":true,"path":"2019/05/25/CSS 书写顺序与常用命名参考/","link":"","permalink":"http://ldc5886.github.io/2019/05/25/CSS%20%E4%B9%A6%E5%86%99%E9%A1%BA%E5%BA%8F%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E5%8F%82%E8%80%83/","excerpt":"","text":"注意事项: 1.一律小写;2.尽量用英文;3.不加中杠和下划线;4.尽量不缩写，除非一看就明白的单词. ###推荐的 CSS 书写顺序显示属性 12345displaylist-stylepositionfloatclear 自身属性 123456widthheightmarginpaddingborderbackground 文本属性 12345678colorfonttext-decorationtext-alignvertical-alignwhite-spaceother textcontent ###网页内容类 标题: title摘要: summary箭头： arrow商标： label网站标志： logo转角/圆角： corner横幅广告： banner子菜单： subMenu搜索： search搜索框： searchBox登录： login登录条：loginbar工具条： toolbar下拉： drop标签页： tab当前的： current列表： list滚动： scroll服务： service提示信息： msg热点：hot新闻： news小技巧： tips下载： download栏目标题： title热点： hot加入： joinus注册： regsiter指南： guide友情链接： friendlink状态： status版权： copyright按钮： btn合作伙伴： partner投票： vote左右中：left right center ###注释的写法: 123/* Footer */内容区/* End Footer */ ###id的命名: ####页面结构 容器: container页头：header内容：content/container页面主体：main页尾：footer导航：nav侧栏：sidebar栏目：column页面外围控制整体布局宽度：wrapper左右中：left right center ####导航 导航：nav主导航：mainnav子导航：subnav顶导航：topnav边导航：sidebar左导航：leftsidebar右导航：rightsidebar菜单：menu子菜单：submenu标题: title摘要: summary ####功能 标志：logo广告：banner登陆：login登录条：loginbar注册：regsiter搜索：search功能区：shop标题：title加入：joinus状态：status按钮：btn滚动：scroll标签页：tab文章列表：list提示信息：msg当前的: current小技巧：tips图标: icon注释：note指南：guild服务：service热点：hot新闻：news下载：download投票：vote合作伙伴：partner友情链接：link版权：copyright ###class的命名: ####颜色使用颜色的名称或者16进制代码,如 123.red &#123; color: red; &#125;.f60 &#123; color: #f60; &#125;.ff8600 &#123; color: #ff8600; &#125; ####字体大小直接使用”font+字体大小”作为名称,如 12.font12px &#123; font-size: 12px; &#125;.font9pt &#123;font-size: 9pt; &#125; ####对齐样式使用对齐目标的英文名称,如 12.left &#123; float:left; &#125;.bottom &#123; float:bottom; &#125; ####标题栏样式使用”类别+功能”的方式命名,如 12.barnews &#123; &#125;.barproduct &#123; &#125;","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"css","slug":"css","permalink":"http://ldc5886.github.io/tags/css/"}],"author":"D橙"},{"title":"js笔记","slug":"js笔记1","date":"2019-05-23T16:00:00.000Z","updated":"2019-10-13T14:34:27.389Z","comments":true,"path":"2019/05/24/js笔记1/","link":"","permalink":"http://ldc5886.github.io/2019/05/24/js%E7%AC%94%E8%AE%B01/","excerpt":"","text":"1.js版本：发布时叫ECMAScript，简称ES，2015年发布了ES2015版，大家也称它为ES6（非官方命名，从2015开始只有年份版本号，无数字版本号了）。 2.ES2015开始，定义变量和变量名的关键词用let，已经不推荐用var了，两者对代码的影响有很多的不同，以后学到需留意。 3.ES6可以用来做开发，然后上线前可以打包然后通过babel来将它编译成对应的ES5代码，从而解决ie和其它低版本浏览器对ES2015及其新版本的兼容问题。 4.ES5里，定义变量用var（变量）和funceion，而ES6里，定义变量用let（变量）、conat（常量）和function。写代码时，要么全用ES5的规则定义变量，要么全用ES6的规则定义变量，绝对不能串着用。 5.定义变量名时把变量名都统一的放在前面一起 6.关于变量名的规定：6.1不能使用JS关键词或保留词，如let、function、static、float等（用了会报错） 6.2不能使用JS里已经被赋予了意义的词，如document、alert等（用了不会报错!!!，但不利于团队合作） 6.3组成名字的字符最好是数字、字母、_和$四种，而且不能以数字开头。（其它的如汉字等也可以用，不会报错，但最好是不用，以防编译出现问题）（减号-绝对不行！！！） 6.4变量名最好能见名知意，例如常用o+变量名表示html里的对象节点等，同时变量名推荐使用驼峰命名法， 7.变量名=数据类型let定义的变量名不能重名，否则会报错 8.常量const不允许初始不赋值，即不能写为const x=；（let可以这么写）但可以写成const x=undefined； 9.数组定义是可以换行的，但要记得加逗号 10.n维数组就是数组里面再套n-1层数组 11.let 变量名={属性名1：属性值1，属性名2：属性值2}； 取值时 用变量名.属性名来取，属性名命名规则参考变量名。例如let x={name：“123”，age：12}；取值则是x.age，x.name等 JS的对象选取方式例： 12345&lt;div id=&quot;wrap&quot;&gt; &lt;p&gt;&lt;/p&gt; 1 &lt;p&gt;&lt;/p&gt; 2 &lt;/div&gt; &lt;p class=“text”&gt;&lt;/p&gt; 3 用标签名、id等属性来选取： 1234let a = document.getElementsByName(&quot;p&quot;);取到123.let ap = oWrap.getElementsByName(&quot;p&quot;);取到12.let p = oWrap.getElementsByClassName(&quot;text&quot;);取到3.(ClassName不兼容IE8)let oWrap = document.getElementById(&quot;wrap&quot;);取到div. （getElementsByName、getElementsByClassName等属性很多节点都有，区别在于document是从全文去找，而类似oWrap等的节点则只是从节点的范围里去找。）（getElementById不同！它只属于document节点才有，因为id唯一，所以其他节点没有这个属性） 用选择器来选取： let ap = document.querySelectorAll(&quot;#wrap p&quot;);取到12.let ap = document.querySelector(&quot;#wrap p&quot;);取到1.(无All时取到的是选择器的第一个元素。query的这两个兼容至IE8，不兼容IE7及以下) 考虑系统兼容性问题时，因为xp系统自带的就是IE8，所以一般极限只考虑到IE8，低于IE8的不考虑。 JS操作CSSJS操作CSS内部样式时，解析的都是CSS，JS操作的样式和CSS里的样式依据CSS使用的优先级来判断，谁优先级高就用谁的。 内部样式1let oCss = ducument.getElementsByClassName(&quot;style&quot;); 或 let oCss = ducument.getElementsById(&quot;css&quot;); 行内样式let oDiv;（需注意，操作是针对对象的） 读取操作：console.log(oDiv.title);（不改变其内部的值，只是读取输出） 写入操作: 123456oDiv.title=&quot;123&quot;;(改title);oDiv.className=&quot;123&quot;;(改class)(较特殊)oWrap.innerHTML += &quot;123&quot;;(在原有基础上加123)oWrap.style.height = &quot;100px&quot;;oWrap.style.backgroundColor = &quot;pink&quot;;上两项综合可写为oWrap.style.cssText += &quot;height:100px,background-color:pink&quot;;(其他属性也可以往里加，用逗号分隔) 注意 oWrap.style += &quot;123&quot;;这个赋值语句不能用！！！因为style这个属性十分特殊，一个节点的style属性是存储着这个节点所有类别样式的对象，简单说，其是objict型，不是字符串，所以不能用 自定义标签属性-getAttribute 获取自定义标签属性，如oWrap.getAttribute(&quot;afei&quot;);-setAttribute 设置自定义标签属性-removeAttribute 移除自定义标签属性 （以上的不仅可以操作非法的标签属性，合法的也可以操作，但一般不用于操作合法的，因为太麻烦，合法的操作应该用Id、className等进行。） innerHTML 和 innerTextinnerHTML可以解析HTML标签结构，类似文本加粗之类的效果可以体现出来，innerText则不可以。 例如： 12oWrap.innerHTML = &quot;&lt;b&gt;我&lt;/b&gt;很帅“； 输出结果为我很帅，”我“字会被加粗。oWrap.innerText = &quot;&lt;b&gt;我&lt;/b&gt;很帅“； 输出结果为&lt;b&gt;我&lt;/b&gt;很帅，完全原样输出。 火狐浏览器低版本不支持innerText，要换成.texeContent innerHTML 和 innerText都获取不到input中输入的值，input输入的值是存储在value里面的，若要操作其输入值，应使用innerValue属性 symbol的使用 symbol是ES6（或称JS6或ES2015）里面的，若不是使用ES6语法编写，则symbol不允许使用！ let x,y;在访问变量时，x.y不成立，因为.无法访问变量，x.属性名才是是访问变量的正确用法。 symbol会创建一个独一无二的值，常常用于解决变量冲突的问题。 x[symbol(&quot;age&quot;)] = 88;若用console.log(x[symbol(&quot;age&quot;)])是取不到上面symbol的值的！因为这里又新创建了一个独一无二的symbol，和上面的symbol是不同的，所以取不到值（两者同名同值，看着一样，但由于symbol是独一无二的，因此实际上它们两个是不同的！！！）要取到上面创建的symbol值，应该用let y = symbol(&quot;age&quot;); console.log(x[y]);来取。 函数相关 不同的对象可以有相同的类，对象是通过类来产生的。例如： div id=wrap与div id=box这两个对象就是相同类下的不同实体。 函数在数据类型上是属于object型的，其一般是用于对代码的封装，虽然赋值也可以用函数，但一般是用对象进行赋值操作。。 3.对象类型与基础数据类型的 区别 在于，对象类型可以被赋予一些自定义属性，然后可以通过类似 a.goudan = &quot;123&quot;;的方式来赋值，而基础数据类型则不可以。 4.函数的定义方式 let a =function(){}; 或 function a(){};。 函数的执行方式：function a(){...}; 主动执行a()；非主动执行不准加（）。 被动执行document.onClick = a;或document.onClick = function{a()}; typeoftypeof用于显示数据类型(是显示不是定义！！显示为该种类型，并不能说明就是该种类型，有几个特殊的，要注意区分)，基本用法为let a = 10; console.log(typaof a)；此时，输出的结果为number。 let a = 10， b = typaof a; console.log(typaof b)；此时，输出的结果为string。 let a = null; console.log(typaof a)；此时，输出的结果为string。 （此处有问题！！null应该是null类型！不是object类型！但typeof在检测null类型时会返回object值。 同理，在检测function时，typaof会返回function，但这只是typaof为了区分function与其他才会返回这个值，并不能说明有function这种类型！！！） 笔记 let w = oWrap.style.width; 后，需注意w = &quot;100px&quot;;和oWrap.style.width = &quot;100px&quot;;是不同的，因为等号是单向赋值的意思，表示单向的把右边给左边。前者是再次给变量赋值，后者是更改属性值，不等同！！！ 将小数转换成指数，运算后在除以对应的倍数来得出结果，可解决JS里小数运算后精度丢失的问题。 JS里没有百分数的概念，输入百分数都会以小数的情况来表示。而符号%表示取余数的意思，例如alert（10%3）；弹出结果是1。 alert（10.5%3）；弹出结果是1.5。 隐式类型转换let a =“10”，b = 20； alert（a+b）；弹出的结果是1020，这个结果是字符串型，但b里的值仍然是数字而不是字符串。alert（1+2+“8”）；弹出结果38.alert（“8”+1+2）；弹出结果812. （先乘除后加减，同一级别从左到右）（+号两边任意一边有字符串，那么都会进行隐式字符串转换步骤，将另一边也转成字符串再进行拼接输出，布尔值和数字运算时，布尔值会转成1和0进行运算。） 除开number string`` boolean之外，比如去讨论一个对象和另一个对象的加法是没有实际意义的。 jsfuck课外可以自己了解一下。 12345let a =“10”，b = “5”； alert（a-b）；弹出的结果是5，数字型。let a =“10”，b = “5”； alert（a*b）；弹出的结果是50，数字型。let a =“10”，b = “5”； alert（a/b）；弹出的结果是2，数字型。 出现不合理的运算之后，例如alert（“打” * “热”）；会显示NaN，即No a Number的意思（输出NaN这不是报错！！！）。NaN是一个关键词，它不是一个数字，但却属于数据类型（不是所有的数字类型都是数字，而是所有的数字和NaN一起组成了数字类型） 自增自减 let a = 10； console.log（a++）；console.log（a）；输出10,11. let a = 10； console.log（++a）；console.log（a）；输出11,11. （先赋值再自增和先自增再赋值的区别） 自减同1。 ++和--进行隐式转换时会强行变数字进行运算，最终输出的值也是数字，无法转成数字的，输出NaN。 模板字符串相关 模板字符串是es6的，不属于es5的内容 普通字符串内部不能直接换行，内部换行只能+号拼接，但模板字符串内部可以直接换行。 普通字符串 123456789let x = “1234”；oWrap.innerHTML = &quot;&lt;div&gt;&quot;+ &quot;&lt;ul&gt;&quot;+ &quot;&lt;li&gt;&quot;+ &quot;&lt;p&gt;&quot; + x +&quot;&lt;/p&gt;&quot; + &quot;&lt;/li&gt;&quot;+ &quot;&lt;ul&gt;&quot;+ &quot;&lt;/div&gt;&quot;; x不能用“”包着，要独立出来才能表示变量。 模板字符串 123456789let x = “1234”；oWrap.innerHTML = `&lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;$&#123;x&#125;&lt;/p&gt; &lt;/li&gt; &lt;ul&gt;+ &lt;/div&gt;`; x用${}包着，表示变量。 若要在字符串中加入$或“”或{}或\\的符号，需在前面加上转义字符\\,表示成\\$或\\&quot;\\&quot;或\\{\\}或\\\\的形式才行。","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"js","slug":"js","permalink":"http://ldc5886.github.io/tags/js/"}],"author":"D橙"},{"title":"JS ClassName赋值方式报错","slug":"JS ClassName赋值方式报错","date":"2019-05-22T16:00:00.000Z","updated":"2019-10-13T14:42:49.473Z","comments":true,"path":"2019/05/23/JS ClassName赋值方式报错/","link":"","permalink":"http://ldc5886.github.io/2019/05/23/JS%20ClassName%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F%E6%8A%A5%E9%94%99/","excerpt":"ClassName赋值方式错误","text":"ClassName赋值方式错误 报错信息文字放大与缩小功能实现不了？点击button按钮无效？ 123456789101112131415161718button class=\"smaller\"&gt;-&lt;/button&gt;p&gt;它终于来了！&lt;/p&gt;script&gt;let oBtnB = document.getElementsByClassName(\"bigger\"), oP = document.getElementsByTagName(\"p\"), num = 19; //原始字号大小 oBtnB.onclick = function () &#123; num = ++num; for (let i=0; num&lt;27 &amp;&amp; i&lt;=3; i++) &#123; //改变字号，同时限制最大字号为26px oP[i].style.fontSize = num + \"px\"; &#125; if(num&gt;26)&#123;num=26&#125; //重置num，使num大小超出最大字号后不随点击次数变化&#125;;/script&gt; 报错分析ClassName获取方式错误，上述获取代码不完整，标签导致没选取上，完整代码应为 1oBtnB = document.getElementsByClassName(&quot;bigger&quot;)[0];","categories":[{"name":"used","slug":"used","permalink":"http://ldc5886.github.io/categories/used/"}],"tags":[{"name":"error","slug":"error","permalink":"http://ldc5886.github.io/tags/error/"}],"author":"D橙"},{"title":"uni-app 报错","slug":"uni-app 报错","date":"2019-05-19T16:00:00.000Z","updated":"2019-10-13T14:40:49.977Z","comments":true,"path":"2019/05/20/uni-app 报错/","link":"","permalink":"http://ldc5886.github.io/2019/05/20/uni-app%20%E6%8A%A5%E9%94%99/","excerpt":"Unterminated string constant","text":"Unterminated string constant 报错信息console控制台报错 Unterminated string constant 报错分析未终止的字符串常数 未修改前 1234setTimeout(\"uni.navigateTo(\"&#123;url: '../show/show',animationType: 'pop-in',animationDuration: 200&#125;)\",5000); 未修改前，setTimeout函数内部部分内容存在回车换行，因此报错。 故而需要取消字符串部分的回车换行，使文本单行排列，即可解决 修改后 1setTimeout(\"uni.navigateTo(&#123;url: '../show/show',animationType: 'pop-in',animationDuration: 200&#125;)\",5000);","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"error","slug":"error","permalink":"http://ldc5886.github.io/tags/error/"},{"name":"uni-app","slug":"uni-app","permalink":"http://ldc5886.github.io/tags/uni-app/"}],"author":"D橙"},{"title":"uni-app 报错","slug":"uni-app 报错2","date":"2019-05-19T16:00:00.000Z","updated":"2019-10-13T14:41:21.449Z","comments":true,"path":"2019/05/20/uni-app 报错2/","link":"","permalink":"http://ldc5886.github.io/2019/05/20/uni-app%20%E6%8A%A5%E9%94%992/","excerpt":"Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.","text":"Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead. 报错信息console控制台报错 Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead. 报错分析在一个组件模板中应该只存在一个根元素，所以在每个组件操作中都应该只有一个根元素。 1234&lt;template&gt; &lt;text&gt;&lt;/text&gt; &lt;button v-on:click=&quot;backIndex&quot;&gt;&lt;/button&gt;&lt;/template&gt; 未修改前，一个template中存在多个根，因此报错。 故而只需要在外层套一个div或者其他元素包裹所有的元素即可解决 123456&lt;template&gt;&lt;view&gt; &lt;text&gt;&lt;/text&gt; &lt;button v-on:click=&quot;backIndex&quot;&gt;&lt;/button&gt;&lt;/view&gt;&lt;/template&gt;","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"error","slug":"error","permalink":"http://ldc5886.github.io/tags/error/"},{"name":"uni-app","slug":"uni-app","permalink":"http://ldc5886.github.io/tags/uni-app/"}],"author":"D橙"},{"title":"layui 报错","slug":"layui 报错","date":"2019-05-17T16:00:00.000Z","updated":"2019-10-13T14:41:57.065Z","comments":true,"path":"2019/05/18/layui 报错/","link":"","permalink":"http://ldc5886.github.io/2019/05/18/layui%20%E6%8A%A5%E9%94%99/","excerpt":"l.push is not a function","text":"l.push is not a function 报错信息table标签与内容主体部分的btn按钮都未渲染出来，且console控制台报错 123TypeError: l.push is not a function layui.js:2:1694c http://localhost:233/layui/layui.js:2:1694r http://localhost:233/layui/layui.js:2:1656 报错分析经查，此为使用格式错误引起 1layui.use(&apos;element&apos;,&apos;table&apos;, function()..... 未修改前，模块部分未用[]括起，因此报错。 故而需要在外层套一个[]即可解决 1layui.use([&apos;element&apos;,&apos;table&apos;], function().....","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"error","slug":"error","permalink":"http://ldc5886.github.io/tags/error/"},{"name":"layui","slug":"layui","permalink":"http://ldc5886.github.io/tags/layui/"}],"author":"D橙"},{"title":"layui 报错","slug":"layui 报错 (2)","date":"2019-05-17T16:00:00.000Z","updated":"2019-10-13T14:43:21.649Z","comments":true,"path":"2019/05/18/layui 报错 (2)/","link":"","permalink":"http://ldc5886.github.io/2019/05/18/layui%20%E6%8A%A5%E9%94%99%20(2)/","excerpt":"s.push is not a function","text":"s.push is not a function 报错信息console控制台报错 1TypeError: s.push is not a function layui.js:5:2830 报错分析经查，此为使用格式错误引起 1return &lt;input type=&quot;checkbox&quot; name=&quot;used&quot; value=&quot;$&#123;d._id&#125;&quot; lay-skin=&quot;switch&quot; lay-text=&quot;可用|不可用&quot; lay-filter=&quot;usedDemo&quot; $&#123;d.used === true ? &apos;checked&apos; : &apos;&apos;&#125;&gt; 未修改前，${d._id}无法代表变量d._id，因此报错。 用${}表示变量，需要在外层加一对上引号（esc键下方的那个键，这里我不知道在md文件里怎么表示出来）才可以使用 1return `&lt;input type=&quot;checkbox&quot; name=&quot;used&quot; value=&quot;$&#123;d._id&#125;&quot; lay-skin=&quot;switch&quot; lay-text=&quot;可用|不可用&quot; lay-filter=&quot;usedDemo&quot; $&#123;d.used === true ? &apos;checked&apos; : &apos;&apos;&#125;&gt;`","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"error","slug":"error","permalink":"http://ldc5886.github.io/tags/error/"},{"name":"layui","slug":"layui","permalink":"http://ldc5886.github.io/tags/layui/"}],"author":"D橙"},{"title":"hexo主题安装报错","slug":"hexo主题安装报错","date":"2019-05-02T16:00:00.000Z","updated":"2019-10-13T14:44:30.521Z","comments":true,"path":"2019/05/03/hexo主题安装报错/","link":"","permalink":"http://ldc5886.github.io/2019/05/03/hexo%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/","excerpt":"WARN No layout: index.html","text":"WARN No layout: index.html 报错信息hexo博客moho主题安装后 http://localhost:4000/显示的是空白，且报错WARN No layout index.html 报错分析经查，此为config里theme设置错误引起，运行git clone 指令获得miho主题后，在theme主题下保存文件夹的名称为：miho 而在config里的theme设置的是 12345 # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: miho### Docs: https://hexo.io/docs/deployment.html 就会出现这样的WARN。把theme的内容改正为 12345 # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: miho### Docs: https://hexo.io/docs/deployment.html 之后再次运行 12hexo ghexo s 就OK 注意 config若用window自带的记事本编辑，极为容易出现乱码！！此次就是因为我一开始用记事本做的编辑，结果折腾了老半天才查出是这个问题 T_T","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"error","slug":"error","permalink":"http://ldc5886.github.io/tags/error/"},{"name":"miho","slug":"miho","permalink":"http://ldc5886.github.io/tags/miho/"}],"author":"D橙"},{"title":"miho 主题优化及注意事项","slug":"miho 主题优化及注意事项","date":"2019-05-01T16:00:00.000Z","updated":"2019-10-13T14:48:58.481Z","comments":true,"path":"2019/05/02/miho 主题优化及注意事项/","link":"","permalink":"http://ldc5886.github.io/2019/05/02/miho%20%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"优化方法 注意事项 常用命令","text":"优化方法 注意事项 常用命令 一般配置网站标题，副标题，描述等一般配置请参考hexo官方文档 Hexo文章置顶的方法&emsp;&emsp;参考 Hexo文章置顶的方法。 更改网站图标使用在线图标转换工具比特虫将想要的图片转换成图标格式，然后将生成的图标文件命名为favicon，放置在\\hexo\\themes\\miho\\source文件夹下即可 注意事项文章中图片的引用顺序我的hexo文件夹放置路径为E:\\blog\\hexo\\ md文件的存储位置为E:\\blog\\hexo\\source\\_posts 对于md文件当中的图片，我目前使用的方法就是将它们放在 source/images 文件夹中（适用图片较少的情况）。然后通过类似于![miho](/images/文件名.jpg)的方法访问它们。该方法会依次按照 123\\hexo\\source\\images\\文件名.jpg\\hexo\\themes\\miho\\source\\images\\文件名.jpg\\hexo\\public\\images\\文件名.jpg 的顺序索引图片，找到就停止索引，未找到则显示[]中的内容。 文章图片较多的情况请参考设置文章资源文件夹 文章封面图文章的基本配置中，封面图路径由cover_picture确定，尺寸固定为350*150。在我使用时，找不到相对路径对应的文件夹，仅绝对路径生效。 12推上服务器时，使用cover_picture: https://用户名.github.io/images/文件名.jpg本地测试时，使用cover_picture: https://localhost：4000/images/文件名.jpg 当文章基本配置没有cover_picture时，则使用主题配置文件，\\hexo\\themes\\miho\\_config.yml中cover_picture配置的图片。 三. 常用命令&emsp;&emsp;点击此处进入Hexo官网 需要注意以下命令均需要在hexo文件夹内右键鼠标，点击 Git Bash Here，执行，否则会报错！1.1 本地查看效果执行以下命令，执行完即可登录 http://localhost:4000/ 查看效果12$ hexo g$ hexo s 1.2 将本地的 Hexo 文件更新到 Github 的库中12$ hexo g$ hexo d 或者直接执行1$ hexo g -d 执行完每个人都可以通过https://你的用户名.github.io这个链接访问该博客了1.3 发表文章输入以下命令，会在项目 \\hexo\\source_posts 中生成 文章标题.md 文件，文章标题根据需要命名1$ hexo n \"文章标题\" 也可以直接在\\hexo\\source_posts 目录下右键鼠标新建文本文档，改后缀为 .md 即可，还可以将写好的文章（.md文件）直接保存到 \\hexo\\source_posts 文件夹下，这种方法比较方便。1.4 清除缓存清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现站点的更改无论如何也不生效，可能需要运行该命令。1$ hexo c","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://ldc5886.github.io/tags/hexo/"}],"author":"D橙"},{"title":"hexo 博客基础搭建","slug":"hexo 博客基础搭建","date":"2019-04-30T16:00:00.000Z","updated":"2019-10-16T14:39:46.446Z","comments":true,"path":"2019/05/01/hexo 博客基础搭建/","link":"","permalink":"http://ldc5886.github.io/2019/05/01/hexo%20%E5%8D%9A%E5%AE%A2%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/","excerpt":"博客基础搭建的过程资料","text":"博客基础搭建的过程资料 一. 环境搭建&emsp;&emsp;参考 使用 Github Pages 和 Hexo 搭建自己的独立博客。 二. 主题安装&emsp;&emsp;我使用的是miho主题，具体安装及配置方式参考 MiHo-主题安装和配置详情 。可以使用 1$ hexo v 查看当前安装的hexo版本 三. 常用命令&emsp;&emsp;点击此处进入Hexo官网 需要注意以下命令均需要在hexo文件夹内右键鼠标，点击 Git Bash Here，执行，否则会报错！1.1 本地查看效果执行以下命令，执行完即可登录 http://localhost:4000/ 查看效果12$ hexo g$ hexo s 1.2 将本地的 Hexo 文件更新到 Github 的库中12$ hexo g$ hexo d 或者直接执行1$ hexo g -d 执行完每个人都可以通过https://你的用户名.github.io这个链接访问该博客了1.3 发表文章输入以下命令，会在项目 \\hexo\\source_posts 中生成 文章标题.md 文件，文章标题根据需要命名1$ hexo n \"文章标题\" 也可以直接在\\hexo\\source_posts 目录下右键鼠标新建文本文档，改后缀为 .md 即可，还可以将写好的文章（.md文件）直接保存到 \\hexo\\source_posts 文件夹下，这种方法比较方便。1.4 清除缓存清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现站点的更改无论如何也不生效，可能需要运行该命令。1$ hexo c","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://ldc5886.github.io/tags/hexo/"}],"author":"D橙"},{"title":"Vue相关开源资料（转）","slug":"Vue相关开源资料（转）","date":"2019-04-30T16:00:00.000Z","updated":"2019-10-13T14:38:40.346Z","comments":true,"path":"2019/05/01/Vue相关开源资料（转）/","link":"","permalink":"http://ldc5886.github.io/2019/05/01/Vue%E7%9B%B8%E5%85%B3%E5%BC%80%E6%BA%90%E8%B5%84%E6%96%99%EF%BC%88%E8%BD%AC%EF%BC%89/","excerpt":"","text":"awesome-github-vue 是由OpenDigg整理并维护的Vue相关开源项目库集合。我们会定期同步OpenDigg上的项目到这里，也欢迎各位提交项目给我们。 如果收录的项目有错误，可以通过issue反馈给我们。这里的项目Star数不是实时更新的，一般是一周更新一次。 ##本文开源地址：https://github.com/yonghu86/awesome-github-vue Vue相关网站参考： Vue中文帮助网站：http://cn.vuejs.org/ Vue github开源地址：https://github.com/vuejs/vue Vue.js专业中文社区：http://www.vue-js.com/ 前端开发Vue相关：http://www.opendigg.com/tags/front-vue 本文主要是收集与整理Vue相关的开源资料，以供需要的朋友参考。主要包含以下几方面的内容： UI组件 开发框架 实用库 服务端 辅助工具 应用实例 Demo示例 ###UI组件 element ★9305 - 饿了么出品的Vue2的web UI工具套件 Vux ★6802 - 基于Vue和WeUI的组件库 mint-ui ★4776 - Vue 2的移动UI元素 iview ★4458 - 基于 Vuejs 的开源 UI 组件库 Keen-UI ★2363 - 轻量级的基本UI组件合集 vue-material ★2207 - 通过Vue Material和Vue 2建立精美的app应用 muse-ui ★1992 - 三端样式一致的响应式 UI 库 vuetify ★1678 - 为移动而生的Vue JS 2组件框架 vonic ★1494 - 快速构建移动端单页应用 eme ★1390 - 优雅的Markdown编辑器 vue-multiselect ★1166 - Vue.js选择框解决方案 vue-table ★824 - 简化数据表格 VueCircleMenu ★776 - 漂亮的vue圆环菜单 vue-chat ★748 - vuejs和vuex及webpack的聊天示例 radon-ui ★633 - 快速开发产品的Vue组件库 vue-waterfall ★605 - Vue.js的瀑布布局组件 vue-carbon ★595 - 基于 vue 开发MD风格的移动端 vue-beauty ★569 - 由vue和ant design创建的优美UI组件 vue-blu ★557 - 帮助你轻松创建web应用 vueAdmin ★556 - 基于vuejs2和element的简单的管理员模板 vue-syntax-highlight ★551 - Sublime Text语法高亮 vue-infinite-scroll ★524 - VueJS的无限滚动指令 Vue.Draggable ★493 - 实现拖放和视图模型数组同步 vue-awesome-swiper ★476 - vue.js触摸滑动组件 vue-calendar ★465 - 日期选择插件 bootstrap-vue ★458 - 应用于Vuejs2的Twitter的Bootstrap 4组件 vue-swipe ★361 - VueJS触摸滑块 vue-amap ★346 - 基于Vue 2和高德地图的地图组件 vue-chartjs ★333 - vue中的Chartjs的封装 vue-datepicker ★331 - 日历和日期选择组件 markcook ★318 - 好看的markdown编辑器 vue-google-maps ★287 - 带有双向数据绑定Google地图组件 vue-progressbar ★248 - vue轻量级进度条 vue-picture-input ★236 - 移动友好的图片文件输入组件 vue-infinite-loading ★224 - VueJS的无限滚动插件 vue-upload-component ★204 - Vuejs文件上传组件 vue-datetime-picker ★197 - 日期时间选择控件 vue-scroller ★196 - Vonic UI的功能性组件 vue2-calendar ★181 - 支持lunar和日期事件的日期选择器 vue-video-player ★178 - VueJS视频及直播播放器 vue-fullcalendar ★176 - 基于vue.js的全日历组件 rubik ★170 - 基于Vuejs2的开源 UI 组件库 VueStar ★169 - 带星星动画的vue点赞按钮 vue-mugen-scroll ★167 - 无限滚动组件 mint-loadmore ★167 - VueJS的双向下拉刷新组件 vue-tables-2 ★162 - 显示数据的bootstrap样式网格 vue-virtual-scroller ★158 - 带任意数目数据的顺畅的滚动 DataVisualization ★149 - 数据可视化 vue-quill-editor ★149 - 基于Quill适用于Vue2的富文本编辑器 Vueditor ★138 - 所见即所得的编辑器 vue-html5-editor ★132 - html5所见即所得编辑器 vue-msgbox ★127 - vuejs的消息框 vue-slider ★126 - vue 滑动组件 vue-core-image-upload ★124 - 轻量级的vue上传插件 vue-slide ★121 - vue轻量级滑动组件 vue-lazyload-img ★118 - 移动优化的vue图片懒加载插件 vue-drag-and-drop-list ★114 - 创建排序列表的Vue指令 vue-progressive-image ★107 - Vue的渐进图像加载插件 vuwe ★107 - 基于微信WeUI所开发的专用于Vue2的组件库 vue-dropzone ★105 - 用于文件上传的Vue组件 vue-charts ★101 - 轻松渲染一个图表 vue-swiper ★95 - 易于使用的滑块组件 vue-images ★93 - 显示一组图片的lightbox组件 vue-carousel-3d ★91 - VueJS的3D轮播组件 vue-region-picker ★89 - 选择中国的省份市和地区 vue-typer ★89 - 模拟用户输入选择和删除文本的Vue组件 vue-impression ★88 - 移动Vuejs2 UI元素 vue-datatable ★87 - 使用Vuejs创建的DataTableView vue-instant ★86 - 轻松创建自动提示的自定义搜索控件 vue-dragging ★86 - 使元素可以拖拽 vue-slider-component ★85 - 在vue1和vue2中使用滑块 vue2-loading-bar ★76 - 最简单的仿Youtube加载条视图 vue-datepicker ★75 - 漂亮的Vue日期选择器组件 vue-video ★70 - Vue.js的HTML5视频播放器 vue-toast-mobile ★68 - VueJS的toast插件 vue-image-crop-upload ★67 - vue图片剪裁上传组件 vue-tooltip ★66 - 带绑定信息提示的提示工具 vue-highcharts ★66 - HighCharts组件 vue-touch-ripple ★62 - vuejs的触摸ripple组件 coffeebreak ★61 - 实时编辑CSS组件工具 vue-datasource ★60 - 创建VueJS动态表格 vue2-timepicker ★60 - 下拉时间选择器 vue-date-picker ★59 - VueJS日期选择器组件 vue-scrollbar ★58 - 最简单的滚动区域组件 vue-quill ★56 - vue组件构建quill编辑器 vue-google-signin-button ★55 - 导入谷歌登录按钮 vue-svgicon ★53 - 创建svg图标组件的工具 vue-float-label ★49 - VueJS浮动标签模式 vue-baidu-map ★46 - 基于 Vue 2的百度地图组件库 vue-social-sharing ★45 - 社交分享组件 vue2-editor ★44 - HTML编辑器 vue-tagsinput ★41 - 基于VueJS的标签组件 vue-easy-slider ★41 - Vue 2.x的滑块组件 datepicker ★38 - 基于flatpickr的时间选择组件 vue-chart ★37 - 强大的高速的vue图表解析 vue-music-master ★37 - vue手机端网页音乐播放器 handsontable ★35 - 网页表格组件 vue-simplemde ★35 - VueJS的Markdown编辑器组件 vue-popup-mixin ★35 - 用于管理弹出框的遮盖层 cubeex ★33 - 包含一套完整的移动UI vue-fullcalendar ★32 - vue FullCalendar封装 vue-material-design ★32 - Vue MD风格组件 vue-morris ★31 - Vuejs组件封装Morrisjs库 we-vue ★30 - Vue2及weui1开发的组件 vue-image-clip ★29 - 基于vue的图像剪辑组件 vue-bootstrap-table ★29 - 可排序可检索的表格 vue-radial-progress ★28 - Vue.js放射性进度条组件 vue-slick ★28 - 实现流畅轮播框的vue组件 vue-pull-to-refresh ★27 - Vue2的上拉下拉 vue-form-2 ★26 - 全面的HTML表单管理的解决方案 vue-side-nav ★26 - 响应式的侧边导航 mint-indicator ★26 - VueJS移动加载指示器插件 chartjs ★24 - Vue Bulma的chartjs组件 vue-scroll ★24 - vue滚动 vue-ripple ★24 - 制作谷歌MD风格涟漪效果的Vue组件 vue-touch-keyboard ★22 - VueJS虚拟键盘组件 vue-chartkick ★22 - VueJS一行代码实现优美图表 vue-ztree ★21 - 用 vue 写的树层级组件 vue-m-carousel ★20 - vue 移动端轮播组件 vue-datepicker-simple ★20 - 基于vue的日期选择器 vue-tabs ★20 - 多tab页轻型框架 vue-verify-pop ★19 - 带气泡提示的vue校验插件 vue-parallax ★15 - 整洁的视觉效果 vue-img-loader ★14 - 图片加载UI组件 vue-typewriter ★13 - vue组件类型 vue-smoothscroll ★12 - smoothscroll的VueJS版本 vue-city ★10 - 城市选择器 vue-tree ★10 - vue树视图组件 vue-ios-alertview ★8 - iOS7+ 风格的alertview服务 dd-vue-component ★7 - 订单来了的公共组件库 paco-ui-vue ★7 - PACOUI的vue组件 vue-cmap ★5 - Vue China map可视化组件 vue-button ★4 - Vue按钮组件 ###开发框架 vue.js ★45466 - 流行的轻量高效的前端组件化方案 vue-admin ★3222 - Vue管理面板框架 electron-vue ★1273 - Electron及VueJS快速启动样板 vue-2.0-boilerplate ★241 - Vue2单页应用样板​ vue-spa-template ★223 - 前后端分离后的单页应用开发 Framework7-Vue ★210 - VueJS与Framework7结合 vue-bulma ★132 - 轻量级高性能MVVM Admin UI框架 vue-webgulp ★100 - 仿VueJS Vue loader示例 vue-element-starter ★34 - vue启动页 ###实用库 vuex ★5997 - 专为 Vue.js 应用程序开发的状态管理模式 vuelidate ★750 - 简单轻量级的基于模块的Vue.js验证 qingcheng ★677 - qingcheng主题 vue-desktop ★461 - 创建管理面板网站的UI库 vue-meta ★257 - 管理app的meta信息 vue-axios ★209 - 将axios整合到VueJS的封装 vue-svg-icon ★116 - vue2的可变彩色svg图标方案 avoriaz ★110 - VueJS测试实用工具库 vue-framework7 ★83 - 结合VueJS使用的Framework7组件 vue-bootstrap-modal ★78 - vue的Bootstrap样式组件 vuep ★72 - 用实时编辑和预览来渲染Vue组件 vue-online ★67 - reactive的在线和离线组件 vue-lazy-render ★66 - 用于Vue组件的延迟渲染 vue-password-strength-meter ★65 - 交互式密码强度计 element-admin ★57 - 支持 vuecli 的 Element UI 的后台模板 vue-electron ★55 - 将选择的API封装到Vue对象中的插件 cleave ★55 - 基于cleave.js的Cleave组件 vue-events ★54 - 简化事件的VueJS插件 vue-shortkey ★53 - 应用于Vue.js的Vue-ShortKey 插件 vue-cordova ★50 - Cordova的VueJS插件 vue-router-transition ★49 - 页面过渡插件 vue-gesture ★48 - VueJS的手势事件插件 http-vue-loader ★46 - 从html及js环境加载vue文件 vue-qart ★46 - 用于qartjs的Vue2指令 vuemit ★44 - 处理VueJS事件 vue-websocket ★42 - VueJS的Websocket插件 vue-local-storage ★41 - 具有类型支持的Vuejs本地储存插件 lazy-vue ★41 - 懒加载图片 vue-bus ★36 - VueJS的事件总线 vue-reactive-storage ★35 - vue插件的Reactive层 vue-notifications ★32 - 非阻塞通知库 vue-lazy-component ★32 - 懒加载组件或者元素的Vue指令 v-media-query ★32 - vue中添加用于配合媒体查询的方法 vue-observe-visibility ★31 - 当元素在页面上可见或隐藏时检测 vue-ts-loader ★29 - 在Vue装载机检查脚本 vue-pagination-2 ★28 - 简单通用的分页组件 vuex-i18n ★26 - 定位插件 Vue.resize ★26 - 检测HTML调整大小事件的vue指令 vuex-shared-mutations ★25 - 分享某种Vuex mutations vue-file-base64 ★16 - 将文件转换为Base64的vue组件 modal ★15 - Vue Bulma的modal组件 Famous-Vue ★15 - Famous库的vue组件 leo-vue-validator ★13 - 异步的表单验证组件 Vue-Easy-Validator ★11 - 简单的表单验证 vue-truncate-filter ★9 - 截断字符串的VueJS过滤器 vue-zoombox ★9 - 一个高级zoombox vue-input-autosize ★5 - 基于内容自动调整文本输入的大小 vue-lazyloadImg ★3 - 图片懒加载插件 ###服务端 nuxt.js ★2743 - 用于服务器渲染Vue app的最小化框架 express-vue ★137 - 简单的使用服务器端渲染vue.js vue-ssr ★67 - 非常简单的VueJS服务器端渲染模板 vue-ssr ★56 - 结合Express使用Vue2服务端渲染 vue-easy-renderer ★22 - Nodejs服务端渲染 ###辅助工具 DejaVue ★543 - Vuejs可视化及压力测试 vue-play ★445 - 展示Vue组件的最小化框架 vscode-VueHelper ★185 - 目前vscode最好的vue代码提示插件 vue-generate-component ★39 - 轻松生成Vue js组件的CLI工具 vue-multipage-cli ★33 - 简单的多页CLI VuejsStarterKit ★26 - vuejs starter套件 ###应用实例 koel ★7175 - 基于网络的个人音频流媒体服务 pagekit ★4021 - 轻量级的CMS建站系统 vuedo ★1040 - 博客平台 jackblog-vue ★943 - 个人博客系统 vue-cnode ★597 - 重写vue版cnode社区 CMS-of-Blog ★405 - 博客内容管理器 rss-reader ★326 - 简单的rss阅读器 vue-ghpages-blog ★208 - 依赖GitHub Pages无需本地生成的静态博客 swoole-vue-webim ★97 - Web版的聊天应用 vue-dashing-js ★70 - nuvo-dashing-js的fork fewords ★52 - 功能极其简单的笔记本 vue-blog ★33 - 使用Vue2.0 和Vuex的vue-blog ###Demo示例 Vue-cnodejs ★2113 - 基于vue重写Cnodejs.org的webapp NeteaseCloudWebApp ★1154 - 高仿网易云音乐的webapp vue-zhihu-daily ★875 - 知乎日报 with Vuejs vue-wechat ★732 - vue.js开发微信app界面 vue2-demo ★699 - 从零构建vue2 + vue-router + vuex 开发环境 eleme ★612 - 高仿饿了么app商家详情 vue-demo ★575 - vue简易留言板 maizuo ★498 - vue/vuex/redux仿卖座网 spa-starter-kit ★489 - 单页应用启动套件 vue-music ★485 - Vue 音乐搜索播放 douban ★402 - 模仿豆瓣前端 vue-Meizi ★394 - vue最新实战项目 zhihudaily-vue ★386 - 知乎日报web版 vue-demo-kugou ★310 - vuejs仿写酷狗音乐webapp VueDemo_Sell_Eleme ★307 - Vue2高仿饿了么外卖平台 vue2.0-taopiaopiao ★246 - vue2.0与express构建淘票票页面 vue-leancloud-blog ★239 - 一个前后端完全分离的单页应用 node-vue-server-webpack ★239 - Node.js+Vue.js+webpack快速开发框架 mi-by-vue ★222 - VueJS仿小米官网 vue-fis3 ★199 - 流行开源工具集成demo vue2.x-douban ★188 - Vue2实现简易豆瓣电影webApp vue-demo-maizuo ★188 - 使用Vue2全家桶仿制卖座电影 vue-zhihudaily ★169 - 知乎日报 Web 版本 vue-adminLte-vue-router ★162 - vue和adminLte整合应用 vue-axios-github ★157 - 登录拦截登出功能 Zhihu-Daily-Vue.js ★134 - Vuejs单页网页应用 hello-vue-django ★113 - 使用带有Django的vuejs的样板项目 vue-cnode ★101 - vue单页应用demo x-blog ★100 - 开源的个人blog项目 vue-express-mongodb ★96 - 简单的前后端分离案例 websocket_chat ★91 - 基于vue和websocket的多人在线聊天室 photoShare ★85 - 基于图片分享的社交平台 vue-zhihudaily-2.0 ★81 - 使用Vue2.0+vue-router+vuex创建的zhihudaily notepad ★77 - 本地存储的记事本 vueBlog ★75 - 前后端分离博客 vue-ruby-china ★70 - VueJS框架搭建的rubychina平台 Zhihu_Daily ★70 - 基于Vue和Nodejs的Web单页应用 vue-koa-demo ★60 - 使用Vue2和Koa1的全栈demo vue2.x-Cnode ★50 - 基于vue全家桶的Cnode社区 life-app-vue ★49 - 使用vue2完成多功能集合到小webapp github-explorer ★49 - 寻找最有趣的GitHub库 vue-trip ★48 - vue2做的出行webapp vue-ssr-boilerplate ★47 - 精简版的ofvue-hackernews-2 vue-bushishiren ★45 - 不是诗人应用 houtai ★44 - 基于vue和Element的后台管理系统 ios7-vue ★38 - 使用vue2.0 vue-router vuex模拟ios7 Framework7-VueJS ★38 - 使用移动框架的示例 cnode-vue ★37 - 基于vue和vue-router构建的cnodejs web网站SPA vue-cli-multipage-bootstrap ★36 - 将vue官方在线示例整合到组件中 vue-cnode ★34 - 用 Vue 做的 CNode 官网 HyaReader ★30 - 移动友好的阅读器 zhihu-daily ★28 - 轻松查看知乎日报内容 seeMusic ★27 - 跨平台云音乐播放器 vue-cnode ★22 - 使用cNode社区提供的接口 zhihu-daily-vue ★20 - 知乎日报 sls-vuex2-demo ★20 - vuex2商城购物车demo vue-dropload ★17 - 用以测试下拉加载与简单路由 vue-cnode-mobile ★17 - 搭建cnode社区 Vuejs-SalePlatform ★17 - vuejs搭建的售卖平台demo v-notes ★17 - 简单美观的记事本 vue-starter ★16 - VueJs项目的简单启动页 vue-memo ★7 - 用 vue写的记事本应用","categories":[{"name":"framework","slug":"framework","permalink":"http://ldc5886.github.io/categories/framework/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://ldc5886.github.io/tags/vue/"}],"author":"EricHu"}]}